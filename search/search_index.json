{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>Here can be found all the relative information I've been learnt during my DevOps Consultant career.</p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/","title":"Questions &amp; Answers","text":""},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#github-actions-structure-and-architecture","title":"GitHub Actions structure and architecture","text":"<ol> <li> <p>What is a GitHub Actions Structure?</p> <ul> <li>To create a workflow, you add actions to a .yml file in the .github/workflows directory in your GitHub repository.</li> <li> <p>Workflow -&gt; Job -&gt; Step -&gt; Action. Example: <pre><code># Workflow\nname: A name for workflow\non: push\n\n# Job    \njobs:\n  build:\n    name: name for build action\n    runs-on: ubuntu-latest\n\n    # Step\n    steps:\n\n      # Action\n      - uses: actions/checkout@v1\n      - uses: ./action-a\n      with:\n        MY_NAME: 'Evgenii'\n</code></pre></p> </li> <li> <p><code>Note</code>:  An event triggers the workflow, which contains the job. The job contains the steps. The steps contain the actions. </p> </li> </ul> </li> <li> <p>Generate an anatomy of GitHub Actions: JavaScript, Docker and composite run step actions:</p> <ul> <li> <p>JavaScript action <pre><code>steps:\n- uses: actions/checkout@v1\n- name: npm install and build webpack\n  run: |\n    npm install\n    npm run build\n</code></pre></p> </li> <li> <p>Docker action <pre><code>name: \"Hello Actions\"\ndescription: \"Greet someone\"\nauthor: \"octocat@github.com\"\n\ninputs:\n  MY_NAME:\n    description: \"Who to greet\"\n    required: true\n    default: \"World\"\n\nruns:\n  uses: \"docker\"\n  image: \"Dockerfile\"\n\nbranding:\n  icon: \"mic\"\n  color: \"purple\"\n</code></pre></p> </li> <li> <p>Composite run step action: <pre><code>name: 'Hello World'\ndescription: 'Greet someone'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  random-number:\n    description: \"Random number\"\n    value: ${{ steps.random-number-generator.outputs.random-number }}\nruns:\n  using: \"composite\" # using composite action\n  steps:\n    - run: echo Hello ${{ inputs.who-to-greet }}.\n      shell: bash\n    - id: random-number-generator\n      run: echo \"random-number=$(echo $RANDOM)\" &gt;&gt; $GITHUB_OUTPUT\n      shell: bash\n    - run: echo \"${{ github.action_path }}\" &gt;&gt; $GITHUB_PATH\n      shell: bash\n    - run: goodbye.sh\n      shell: bash\n</code></pre></p> </li> </ul> </li> <li> <p>What are common workflow commands:</p> <ul> <li><code>name</code>: A name for the workflow.</li> <li><code>needs</code>: A workflow run must complete successfully before a dependent workflow run can begin.</li> <li><code>env</code>: Variable set in a workflow, job, or step.</li> <li><code>vars</code>: Variable set at the repository, organization, or environment levels.</li> <li><code>secrets</code>: the names and values of secrets that are available to a workflow run.</li> <li><code>strategy</code>: A strategy for matrix builds.</li> <li><code>matrix</code>: matrix properties defined in the workflow that apply to the job.</li> <li><code>inputs</code>: inputs of a reusable or manually triggered workflow.</li> <li> <p><code>on:</code> attribute is a trigger to specify when the workflow will run. In example above workflow executes on <code>push</code>event. </p> <ul> <li>Ways to use <code>on:</code> attribute:<ol> <li>using single event <code>on: push</code></li> <li>using multiple events: <code>on: [push, pull_request]</code></li> <li>Using activity types:  <pre><code>on: \n  issues: \n    types: \n      - opened\n      - labeled\n</code></pre></li> <li>Using activity types and filters with multiple events: <pre><code>on:\n  label:\n    types:\n      - created\n  push:\n    branches:\n      - main\n</code></pre></li> </ol> </li> <li>Also it is important to remember:<ul> <li><code>workflow_dispatch</code>: allows to trigger a workflow manually from the GitHub Actions UI.</li> <li><code>repository_dispatch</code>: allows to trigger a workflow using GitHub API.<ul> <li>This event requires two things: 1) POST request to a propriate endpoint, 2) configuring workflow to use repository_dispatch event. Example: <pre><code>on:\n  repository_dispatch:\n    types: [opened, deleted]\n</code></pre></li> </ul> </li> </ul> </li> <li> <p>Lastly it is possible to confugure a workflow to run on schedule or a specific webhook events.</p> <ul> <li>The <code>schedule</code> event allows to trigger a workflow to run at specific <code>UTC</code> times using <code>POSIX</code> cron syntax. Example:    <pre><code>on:\n  schedule:\n    - cron:  '0 3 * * SUN'\n</code></pre></li> </ul> </li> <li> <p>The <code>webhook</code> event allows to trigger a workflow when a specific webhook event is received. </p> </li> <li>In the example below a workflow is using <code>check_run</code> event for the <code>rerequested</code> or requested_action` activity types.</li> </ul> <pre><code>on:\n  check_run:\n    types: [rerequested, requested_action]\n</code></pre> </li> </ul> </li> <li> <p>What files are needed for a Javascript action and a Docker action?</p> <ul> <li>JavaScript actions needs following files:<ul> <li><code>action.yml</code></li> <li><code>index.js</code></li> <li><code>node_modules</code></li> <li><code>package.json</code></li> <li><code>package-lock.json</code></li> <li><code>README.md</code></li> </ul> </li> <li>Docker actions needs following files:<ul> <li><code>action.yml</code></li> <li><code>Dockerfile</code></li> <li><code>entrypoint.sh</code></li> <li><code>README.md</code></li> </ul> </li> </ul> </li> <li> <p>What is a required and optional syntax for workflow files and action files.</p> <ul> <li>The syntax for workflow files and action files in GitHub Actions is YAML. YAML is a human-readable data serialization language that is often used for configuration files and data exchange formats. The required metadata and syntax in order to create an action are: 1) <code>Name</code> 2) <code>Description</code> 3) <code>Runs</code>, on the other hand optional parameters are 1) <code>Inputs</code>, 2) <code>Outputs</code>, and 6) <code>Branding</code>.</li> </ul> </li> <li> <p>What are the ways to refer to an action?</p> <ul> <li>There are different ways to refer to an action:<ol> <li>Referencing by a specific commit. <code>- uses: actions/setup-node@c46424eee26de4078d34105d3de3cc4992202b1e</code></li> <li>Refercing by the version of a release. <code>- uses: actions/setup-node@v1</code> or <code>- uses: actions/setup-node@v1.2</code></li> <li>Refernsing by a branch. <code>- uses: actions/setup-node@main</code></li> <li>Referencing by a tag. <code>- uses: actions/javascript-action@v1-beta</code></li> </ol> </li> <li>To effectively manage the releases and versions of software, it is recommended to create a separate branch for releases and test the release on that branch before creating a release tag.</li> </ul> </li> <li> <p>What are all the actions GitHub uses during it's collection?</p> <ol> <li><code>actions/checkout@v2</code> - Checks out a repository into the GitHub Actions runner.</li> <li><code>actions/cache@v2</code> - Caches dependencies and build outputs to improve workflow execution time.</li> <li><code>actions/upload-artifact@v2</code> - Uploads an artifact.</li> <li><code>actions/download-artifact@v2</code> - Downloads a single artifact.</li> <li><code>actions/setup-node@v1</code> - Sets up a Node.js environment for use in actions by:<ul> <li>optionally downloading and caching a version of Node.js by version and adding to PATH.</li> <li>registering problem matchers for error output.</li> </ul> </li> <li><code>azure/webapps-container-deploy@v1</code></li> <li><code>azure/login@v1</code></li> <li><code>azure/docker-login@v1</code></li> </ol> </li> <li> <p>What are all the possible options for GitHub conditionals?</p> <ul> <li>In order to use conditionals in workflow, it requires two main attributes:<ul> <li><code>if</code>: The conditional expression that determines whether the step runs. </li> <li><code>conditionion</code> itself using specifix syntax <code>${{ &lt;expression&gt; }}</code>.</li> </ul> </li> <li>GitHub offers conditionals using a keyword like: 1) <code>contains()</code>, 2) <code>startsWith()</code>, 3) <code>endsWith()</code> and more. Full list of keywords</li> <li>Using <code>github.&lt;condition&gt;</code> or <code>steps.&lt;condition&gt;</code> for example <code>github.event_name == 'push'</code></li> <li>When it comes to variables, contitional keyword can be used only within the context variables or predefined workflow variables inside the <code>env: attribute</code>!</li> <li>the <code>success()</code> function returns true if the step or job has succeeded.</li> <li>Using labels:   <pre><code>jobs:\nset-up-azure-resources:\n  runs-on: ubuntu-latest\n  if: contains(github.event.pull_request.labels.*.name, 'spin up environment')\n  ...\n\ndestroy-azure-resources:\n  runs-on: ubuntu-latest\n  if: contains(github.event.pull_request.labels.*.name, 'destroy environment')\n  ...\n</code></pre></li> </ul> </li> <li> <p>What matrix strategy is used for?</p> <ul> <li><code>matrix</code> strategy is used to run tests in parallel against different system architectures and its versions. </li> <li>For example in the example below, the <code>matrix</code> strategy been configured to produce 4 builds, one for each combination of <code>os</code> and <code>node-version</code>: <pre><code>strategy:\n  matrix:\n      os: [ubuntu-lastest, windows-2016]\n      node-version: [8.x, 10.x]\n</code></pre></li> <li>Other example, including github objects: <pre><code>name: Node.js CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        os: [ubuntu-lastest, windows-2016]\n        node-version: [10.x, 12.x]\n    steps:\n    - uses: actions/checkout@v2\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    - run: npm ci\n    - run: npm run build --if-present\n\n  test:\n    needs: build\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        os: [ubuntu-lastest, windows-2016]\n        node-version: [10.x, 12.x]\n    steps:\n    - uses: actions/checkout@v1\n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    - name: npm install, and tet\n      run: |\n        npm install\n        npm test\n      env:\n        CI: true\n</code></pre></li> </ul> </li> <li> <p>What are the useful workflow commands?</p> <ul> <li><code>echo \"::workflow-command parameter1={data},parameter2={data}::{command value}\"</code></li> <li><code>echo \"::error file=app.js,line=10,col=15::Something went wrong\"</code></li> <li>command should be on a single line, in order to break the line, required to specify URL-encoded line feed character <code>%0A</code></li> <li>Depends on language, the syntax can be different. For example when using <code>JavaScript</code> syntax could be following: <code>core.setOutput('SELECTED_COLOR', 'green');</code></li> <li>Workflow command and parameter names are not case-sensitive.</li> </ul> <p><pre><code>  - name: workflow commands logging messages\n  run: |\n    echo \"::debug::This is a debug message\"\n    echo \"This is an info message\"\n    echo \"::error::This is an error message\"\n    echo \"::warning::This is a warning message\"\n</code></pre> - in order to set the output within the action, the syntax could be:</p> <pre><code>  - name: Set color\n    id: random-color-generator\n    run: echo \"SELECTED_COLOR=green\" &gt;&gt; $GITHUB_OUTPUT\n  - name: Get color\n    run: echo \"The selected color is ${{ steps.random-color-generator.outputs.SELECTED_COLOR }}\"\n</code></pre> </li> <li> <p>How to automate reviews in GitHub using workflows?</p> <ul> <li>In order to run a workflow after a reviewer has approved the pull request, the trigger could be <code>pull-request-review</code>.</li> </ul> <pre><code>steps:\n - name: Label when approved\n   uses: pullreminders/label-when-approved-action@main\n   env:\n     APPROVALS: \"1\"\n     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n     ADD_LABEL: \"approved\"\n</code></pre> </li> </ol> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#secrets-and-variables","title":"Secrets and Variables","text":"<ol> <li> <p>What <code>GITHUB_TOKEN</code> is used for?</p> <ul> <li>Authenticating and authorizing actions to interact with the repository, such as: checking out the code, pushing changes, creating pull requests, creating issues, commenting on pull requests, or updating project boards.</li> </ul> </li> <li> <p>Describe variables in GitHub Actions:</p> <ul> <li>In GitHub users are available to use default envionment variables, context variables and custom environment variables: </li> <li>Default environment variables and context variables are similar to each other, however context can be used within the <code>if</code> attribute as a conditional expression.</li> <li>Custom variables can be defined in the <code>env:</code> attribute of the workflow file. Example:  <pre><code>name: CI\non: push\njobs:\n  prod-check:\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Nice work, $First_Name. Deploying to production server on branch $GITHUB_REF\"\n        env:\n          First_Name: Evgenii\n</code></pre></li> </ul> </li> <li> <p>Which environment variable gives info on which branch and which user initiated a workflow run?</p> <ul> <li><code>$GITHUB_ACTOR</code> provides the username of the user or the name of the GitHub App that initiated the workflow run.</li> <li><code>$GITHUB_REF</code> provides the Git reference (e.g. branch or tag) that triggered the workflow run.</li> <li><code>$GITHUB_REPOSITORY</code> provides the owner and repository name. For example, <code>octocat/Hello-World</code>.</li> <li>To use a default environment variable, <code>$</code> is required followed by the environment variable's name. For example:</li> </ul> <pre><code>jobs:\nprod-check:\n  steps:\n    - run: echo \"Deploying to production server on branch $GITHUB_REF\"\n</code></pre> </li> <li> <p>How to use secret in a an action?</p> <ul> <li>GitHub secrets can be configured at <code>Organization</code> and <code>Repository levels</code>.</li> <li>For <code>Repository</code> level, secrets used <code>ONLY</code> within the repository and doesn't have <code>repository access</code> policy permissions.</li> <li>For <code>Organisation</code> level, secrets has a configurable <code>policy</code> permissions: <code>Repository access</code>. These secrets can be used all around the organisation from a single place.</li> <li> <p>Where are few approaches of using secrets, and they depends on the level and usecase scenario. The example shows all the possible options:</p> <pre><code>steps:\n  - name: \"Login via Azure CLI\" \n    uses: azure/login@v1\n\n    with: # Using repository level secret as an input for the action\n      creds: ${{ secrets.AZURE_CREDENTIALS }} \n\n    # or\n\n    with: # Set the super secret as an input for the action\n      super_secret: ${{ secrets.AZURE_CREDENTIALS }}\n\n    env: # Set the secret as an environment variable\n      super_secret: ${{ secrets.AZURE_CREDENTIALS }}\n\n    inputs: # Set the encrypted secret as an input for the action \n      super_secret:\n        description: 'A super secret'\n        required: true\n</code></pre> </li> <li> <p>When secret is created, an action can only get the secrets as <code>input</code>. In this case the action code could read the value of the input using the <code>INPUT_SUPER_SECRET</code> environment variable.</p> </li> <li>Interesting: No configuration for enterprise level using <code>super_secret</code>?</li> </ul> </li> </ol> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#caching-artifacts-github-packages-and-releases","title":"Caching, Artifacts, GitHub Packages and Releases","text":"<ol> <li> <p>What is a difference between using artefacts and cache?</p> <ul> <li>GitHub provides two ways to reuse dependencies between workflow runs: <code>caching</code> and <code>artifacts</code>. </li> <li><code>Caching</code> allows to persist files generated <code>during</code> the workflow run, such as dependencies or build outputs, and is useful for reducing the time it takes to install dependencies in subsequent runs. </li> <li><code>Artifacts</code> are files or directories that should be persisted <code>after</code> the workflow run has completed, and are used for <code>sharing</code> files between different jobs or for downloading and storing build artifacts for deployment. </li> <li>The main difference between <code>caching</code> and <code>artifacts</code> is that caching is focused on improving performance during the workflow run, while artifacts are focused on sharing files between jobs and workflows after the workflow run has completed. </li> <li>By default, <code>cache</code> is accessible for 7 days, however the retention period can be changed.</li> <li>Size of all caches in a repository is limited to 10 GB.</li> <li>To use cache, it requires to set <code>Key</code> (Refers to the key identifier created when saving and searching for a cache.) and <code>Path</code> (Refers to the file path on the runner to cache or search.) Restore-keys is optional, it constists of alternative existing keys to caches if the desired cache key is not found.</li> <li>By default <code>artifacts</code> are accessible for 90 days after a workflow run has completed, however the retention period can be changed:</li> <li>For <code>public</code> repositories: anywhere between 1 day or 90 days.</li> <li>For <code>private</code> repositories: anywhere between 1 day or 400 days.</li> <li>here GitHub tells themself:  <ul> <li>Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.</li> <li>Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.</li> </ul> </li> </ul> </li> <li> <p>What parameters <code>caching</code> requires and what are optional parameters?</p> <ul> <li><code>Key</code> and <code>Path</code> are required parameters, while <code>Restore-keys</code> is optional.</li> <li>An example of using <code>caching</code>: <pre><code>steps:\n  - uses: actions/checkout@v2\n  - name: Cache NPM dependencies\n    uses: actions/cache@v2\n    with: \n      path: ~/.npm\n      key: ${{ runner.os }}-npm-cahe-${{ hashFiles('**/package-lock.json') }}\n      restore-keys: |\n        ${{ runner.os }}-npm-cache-\n</code></pre></li> </ul> </li> <li> <p>How to pass artifact data between jobs?</p> <ul> <li>In order to pass artifact data between jobs, it is required to use <code>upload-artifact</code> and <code>download-artifact</code> actions.</li> <li>Example of passing artifacts between jobs: <pre><code>name: Share data between jobs\non: push\njobs:\n  job_1:\n    name: Upload File\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Hello World\" &gt; file.txt\n      - uses: actions/upload-artifact@v2\n        with:\n          name: file\n          path: file.txt\n\n  job_2:\n    name: Download File\n    runs-on: ubuntu-latest\n    needs: job_1\n    steps:\n      - uses: actions/download-artifact@v2\n        with:\n          name: file\n      - run: cat file.txt\n</code></pre></li> </ul> </li> <li> <p>What are the Packages GitHub supports in its Package tool?</p> <ul> <li>GitHub Packages is compatible with common package-management client. GitHub Packages supports: <ul> <li><code>npm</code></li> <li><code>NuGet</code></li> <li><code>Maven</code> and <code>Gradle</code></li> <li><code>RubyGems</code></li> </ul> </li> </ul> </li> <li> <p>What is the end point to access logs from the REST API?</p> <ul> <li>The endpoint to access logs from the REST API is: <code>https://api.github.com/repos/{owner}/{repo}/actions/runs/{run_id}/logs</code></li> </ul> </li> <li> <p>GitHub Packages is a package-management service, however what else it is?</p> <ul> <li>GitHub Packages is also a container registry. It allows to <code>store</code>, <code>manage</code>, and <code>deploy</code> container images and it is compatible with Docker, Kubernetes and other cloud-native technologies. </li> </ul> </li> <li> <p>What is the difference between GitHub Packages and Releases</p> <ul> <li>GitHub Packages are used to publish and release libraries to a standard package feed or a container registry.</li> <li>GitHub Releases are used to release a bundle of packaged software, along with the release notes and links to binary files. It is basically a wrap of repository files in tarball or zip format. Releases can be directly downloaded from their unique URL and tracked back to specific commit they were created from.</li> </ul> </li> <li> <p>What is a workflow to publish to GitHub Packages?</p> <ul> <li> <p>The workflow below must exists in the <code>./github/workflows</code> directory.  <pre><code>name: Node.js Package\n\non:\n  release:\n    types: [created]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v1\n        with:\n          node-version: 12\n      - run: npm ci\n      - run: npm test\n\n  publish-gpr:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v1\n        with:\n          node-version: 12\n          registry-url: https://npm.pkg.github.com/\n      - run: npm ci\n      - run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre></p> </li> <li> <p>A workflow above does following:</p> <ul> <li>After build succeedes, <code>publish-gpr</code> runs <code>npm publish</code> to publish the package to the <code>GitHub Package Registry</code>.</li> <li>A job named <code>build</code> runs <code>npm ci</code> to install dependencies directly from the <code>package-lock.json</code> file.</li> <li>The workflow publishes the package to the <code>registry-url: https://npm.pkg.github.com/</code> and uses the <code>GITHUB_TOKEN</code> secret to authenticate.</li> </ul> </li> </ul> </li> <li> <p>How to use GitHub Container Registry to host and manage Docker container images?</p> <ul> <li>GitHub Container Registry allows you to configure who can manage and access packages using fine-grained permissions.</li> <li>After image is built, and user is signed in to GitHub Container Registry at <code>ghcr.io</code>, user can tag and push the latest version of the image to container registry using these commands: <pre><code>echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin\n\ndocker tag IMAGE_ID ghcr.io/OWNER/IMAGE_NAME:latest\n\ndocker push ghcr.io/OWNER/IMAGE_NAME:latest\n</code></pre></li> </ul> </li> <li> <p>What are all the pieces of information users need in order to authenticate to GitHub package manager?</p> <ul> <li>Personal GitHub username</li> <li>Personal Access Token</li> <li>GitHub Package endpoint for package ecosystem</li> </ul> </li> <li> <p>What are the possible endpoints for GitHub Packages?</p> <ul> <li>The basic endpoint for GitHub Packages is <code>https://PACKAGE_TYPE.pkg.github.com/OWNER/REPOSITORY</code></li> <li>So basically if we have a package type of <code>npm</code>, owner of <code>octocat</code> and repository of <code>hello-world</code>, the endpoint   would be <code>https://npm.pkg.github.com/octocat/hello-world</code></li> </ul> </li> <li> <p>There are 4 package ecosystems GitHub refers during the GitHub Actions collections. What is the way to authenticate in each of them?</p> <ol> <li><code>NuGet</code>: <code>dotnet nuget add source https://nuget.pkg.github.com/OWNER/index.json -n github -u OWNER -p [Your PAT Token]</code></li> <li><code>npm</code>: <code>bash npm login --registry=https://npm.pkg.github.com</code></li> <li><code>RubyGems</code>: <code>echo \":github: Bearer GH_TOKEN\" &gt;&gt; ~/.gem/credentials</code></li> <li><code>Maven</code> &amp; <code>Grandle</code>: Can be directly authenticated while pushing</li> </ol> </li> <li> <p>What are the ways of managing packages?</p> <ul> <li>GitHub Packages offers several ways to manage packages:  <ul> <li>Using GitHub API or GraphQL API</li> <li>GitHub Actions</li> </ul> </li> </ul> </li> </ol> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#workflow-templates","title":"Workflow templates","text":"<ol> <li> <p>When GitHub recommends to store actions and workflow templates LOCALLY?</p> <ul> <li>GitHub recommends storing actions and workflow templates locally when its needed to reuse the same actions or workflows across multiple repositories or to maintain version control over actions and workflows.</li> <li>By storing actions and workflows locally, user can define them in a central location and reference them in multiple repositories, instead of duplicating the same actions and workflows across multiple repositories. This can help you maintain consistency and avoid errors or inconsistencies across your repositories.</li> <li>When you store actions and workflows locally, you can also version control them using Git, just like you would with any other code. This means you can track changes to your actions and workflows over time, collaborate with others on updates and improvements, and easily roll back to previous versions if needed.</li> </ul> </li> <li> <p>Where templated workflows should be stored?</p> <ul> <li>By default GitHub templates should be stored in <code>.github/workflows</code> directory.<ul> <li>Organisation templates should be stored in organisation's <code>.github</code> repository. Templates can be found by using <code>Actions</code>, selecting <code>New workflow</code> and finding the organisation's workflow template section titled <code>Worfklows created by &lt;organisation name&gt;</code>.</li> </ul> </li> </ul> </li> </ol> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#deploying-actions-and-control-over-enterprise-organisation-and-repository-level","title":"Deploying actions and control over enterprise, organisation and repository level","text":"<ol> <li> <p>What are all the steps required in order to create / publish an action?</p> <ul> <li>Depends on the visibility <code>public</code> or <code>private</code>. </li> <li> <p>Public actions need their own repository for:</p> <ul> <li><code>versioning</code></li> <li><code>tracking</code></li> <li><code>discoverability</code></li> </ul> </li> <li> <p>Private actions can be stored in any location in the same repository.</p> </li> <li> <p>Regardless of visibility, it's a good practice to include documentation as a README.md file, covering the action's:</p> <ul> <li><code>description</code></li> <li><code>required &amp; optional</code> arguments</li> <li><code>input &amp; output arguments</code></li> <li><code>secrets</code> (e.g. how they should be used and what they are used for)</li> <li><code>environment variables used</code> and an example of how to use it</li> <li>The README.md should provide all the information a user needs to use the action.</li> </ul> </li> <li> <p>In order to publish action to <code>GitHub Marketplace</code>:</p> <ul> <li>GitHub has requirement list, an of all of the requirements are met, GitHub publishes an action immediately to the GitHub Marketplace. </li> <li>Else, GitHub will need to review an action.</li> <li> <p>The repository for the action should only include: </p> <ul> <li><code>metadata file code</code> </li> <li>files necessary for the action.</li> </ul> </li> <li> <p>The action must be in a <code>public</code> repository and must contain a <code>single</code> action.</p> </li> <li> <p>The action's metadata file <code>action.yml</code> must be in the root directory of the repository. </p> <ul> <li><code>name</code> in the metadata file must be <code>unique</code> on the GitHub Marketplace.</li> <li><code>name</code> cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. </li> <li><code>name</code> cannot match an existing GitHub Marketplace category or feature.</li> </ul> </li> <li> <p>Action can be added to <code>GitHub Marketplace</code> by tagging it as a new release and then publishing it.</p> </li> </ul> </li> </ul> </li> <li> <p>How to debug a self-hosted runner?</p> <ul> <li>There are few ways:<ul> <li>Enable runner diagnostics logging. Set the <code>ACTIONS_RUNNER_DEBUG</code> secret in the repository that contains the workflow to <code>true</code></li> <li>Enable step diagnostics logging. Set the <code>ACTIONS_STEP_DEBUG</code> secret in the repository that contains the workflow to <code>true</code></li> <li>GitHub-hosted runners are not supported on GitHub Enterprise Server. However GitHub Enterprise Cloud supports both: GitHub-hosted and self-hosted runners.</li> <li>Users also can:<ul> <li>Check the status of the runner in GitHub Actions settings of the organisation, repository or entreprise where self-hosted runner is registered.</li> <li>Review the activities and automatic updates of the runner in the <code>Runner_</code> files in the <code>_diag</code> folder</li> <li>Review the status of the jobs runner executed in the <code>Worker_</code> files in the <code>_diag</code> folder  </li> <li>Depending on the operation system of the runner, users can also review:<ul> <li><code>MacOS</code>: self-hosted runner application service using <code>launchd</code></li> <li><code>Windows</code>: self-hosted runner application service using <code>PowerShell</code></li> <li><code>Linux</code>:  self-hosted runner application service using <code>journalctl</code> or if jobs require containers, confirm that Docker is configured correctly, installed and running using <code>systemctl</code></li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>How to protect workflow environment?</p> <ul> <li> <p>It make sense to configure workflow envirnment with protection rules and secrets. With the protection a job won't start or access any defined secrets in the environment untill all of the environment's protection rules pass. For now protection rules and environment secrets only apply to public repositories.</p> </li> <li> <p>There are two environment protection rules that are possible to apply to workflows within <code>public repositories</code>, <code>required reviewers</code> and <code>wait timer</code>:</p> </li> <li> <p>Required reviewers allows to set a specific person or team to approve workflow jobs that reference the job's environment.</p> </li> <li>Wait timer can be used to <code>delay</code> a job for a specific amount of time after the job has been <code>triggered</code>.</li> <li> <p>For example if it's necessary to create a workflow to a production environment that a <code>dev</code> team needs to approve before the deployement occurs, the steps would look be:</p> <ol> <li>Create a <code>production environment</code> within the repository</li> <li>Configure the required reviewers environment protection to require an approval from the specific <code>dev</code> team</li> <li>Configure the specific job within the workflow for the <code>production</code> environment</li> </ol> </li> <li> <p>The repository can be created and configured from the repository's <code>Settings</code> tab under <code>Environments</code>.</p> </li> </ul> </li> <li> <p>Everything related to GitHub enterprise/organisation level:</p> <ul> <li>In both levels GitHub Actions use policy can be configured.</li> <li>Most official GitHub-authored actions come automatically bundled with Enterprise Server, and are captured at a point in time from the GitHub Marketplace:</li> <li><code>actions/checkout</code></li> <li><code>actions/upload-artifact</code></li> <li><code>actions/download-artifact</code></li> <li><code>actions/labeler</code></li> <li><code>actions/setup-...</code></li> <li>Workflow templates can be created in both: Enterprise Cloud and Server. Users with write access can create templates to an organization's <code>.github</code> repository. Templates can be stored in <code>public</code> or <code>private</code> repositories of the organisation.</li> <li>In order to create a template user needs: <code>.yml</code> file, and metadata file <code>.properties.json</code> file. Metadata file requires <code>name</code>, <code>description</code> and <code>iconName</code> properties. <code>categories</code> and <code>filePatterns</code> are optional parameters.</li> <li><code>$default-branch</code> placeholder can be used within the <code>on:</code> trigger event inside <code>Workflow</code> section of the action file to reference the default branch of the repository.</li> </ul> </li> <li> <p>How proxy settings should be set for GitHub Enterprise?</p> <ul> <li>Proxy environmnet variables are read when the self-hosted runner application starts, so engineer must set the environment variables before configuring or starting the application. If proxy configuration changes, it requires to restart the self-hosted runner application.</li> <li>In Windows environment the proxy variable names are not case sensitive. On Linux and MacOS the recommended way is to specify all of the environment variable names in a lowercase. If there are environment variables in both uppercase and lowercase on Linux or macOS, for example <code>https_proxy</code> and <code>HTTPS_PROXY</code>, the self-hosted runner application will use the lowercase variable.</li> </ul> </li> <li> <p>What IP Allowlist should contain in order to communicate with self-hosted runners?</p> <ul> <li>IP allowlist should contain IP address or range of self-hosted runners for the communication between self-hosted runner and GitHub.</li> </ul> </li> </ol> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/6.%20Questions%20%26%20Answers/#good-to-know","title":"Good to know","text":"<ol> <li> <p>Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets the <code>GITHUB_SHA</code> (commit SHA) and <code>GITHUB_REF</code> (Git ref) environment variables in the runner environment.</p> </li> <li> <p><code>check_run</code> is an activity event that activity relates to a check run occurs. It has different activity types: <code>created</code>, <code>rerequested</code>, <code>completed</code> and <code>requested_action</code>.</p> </li> <li> <p>GitHub refers that it is possible to connect Enterprise Server to Market place. However you cannot download apps from the Marketplace (AFAIK only actions are allowed to be downloaded from the Marketplace using GHES).</p> </li> <li> <p>self-hosted Labels:</p> <ul> <li>[self-hosted, <code>&lt;operating system&gt;</code>, <code>&lt;hardware architecture&gt;</code>]</li> <li>for example: <code>[self-hosted, linux, ARM64]</code></li> </ul> </li> <li> <p>Read carefully about usage limits! Usage limits</p> </li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/","title":"Introduction to Actions","text":"<p><code>GitHub Actions</code> are packaged scripts to automate tasks in a software development workflow in GitHub. User can configure GitHub Actions to trigger complex workflows that meet his organization's needs. By using GitHub Actions developers can build a reliable and sustainable automated workflow, which leads to a significant decrease in development time. GitHub Actions are scripts that adhere to a yml data format.  Each repository has an Actions tab that provides a quick, automated and easy way to get started with setting up first workflow. If user want to see the workflow, the great way to start would be selecting <code>Configure</code> button to add the script and beging editing the source YML.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#beyond-this-features-actions-tab-allows-users-to","title":"Beyond this features Actions tab allows users to:","text":"<ul> <li>Search for GitHub Actions in the GitHub Marketplace.</li> <li>Search for open-source projects.</li> <li>Write own GitHub Actions from scratch.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#using-github-actions-to-decrease-development-time","title":"Using GitHub Actions to decrease development time","text":"<p>All of the tasks that must happen after the code is written, but before the code can be reliably used for its purpose, can be automated with GitHub Actions.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#this-includes","title":"This includes:","text":"<ul> <li>Ensuring the code passes all unit tests</li> <li>Performing code quality and compliance checks to make sure the source code meets the organization's standards</li> <li>Checking the code and its dependencies for known security issues</li> <li>Building the code integrating new source from (potentially) multiple contributors</li> <li>Ensuring the software passes integration tests</li> <li>Versioning the new build</li> <li>Delivering the new binaries to the appropriate filesystem location</li> <li>Deploying the new binaries to one or more servers</li> </ul> <p>If any of these tasks do not pass, actions reports the issue to the proper individual or team for resolution automatically. This allows the development team to focus on writing code, and not on the tasks that must happen after the code is written! This is just an example of an ideal job for worklow automation, however the biggest challenge is to do these tasks reliable, consistently and in a suistanable manner.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#open-source-github-actions","title":"Open-source GitHub Actions","text":"<p>There are plenty of open source actions available for anyone who wants to use them. Open-source doesn't mean these actions are secure. User's must carefully check them before using then in their project. </p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#recommended-community-stadart-with-open-source-software-is","title":"Recommended community stadart with open-source software is:","text":"<ul> <li>Including README file</li> <li>Including Code of Conduct</li> <li>Including Contributing file</li> <li>Including issue templates </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/1-Introduction-to-GitHub-Actions/#before-users-start-using-open-source-actions-github-recommends-to-check-following","title":"Before user's start using open-source Actions, GitHub recommends to check following:","text":"<ul> <li>Review the action's <code>action.yml</code> file for inputs, outputs, and to make sure the code does what it says it does.</li> <li>Check if the action is in the GitHub Marketplace. This is a good check, even if an action does not have to be on the GitHub Marketplace to be valid.</li> <li>Check if the action is verified in the GitHub Marketplace. This means that GitHub has approved the use of this action. However, you should still review it before using it.</li> <li>Include the version of the action you're using by specifying a Git ref, SHA, or tag.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/","title":"About Actions","text":""},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#github-actions-types","title":"GitHub Actions types","text":"<p>There are three types of GitHub Actions:</p> <ol> <li> <p>JavaScript Actions - these actions don't include the environment in the code. Users should specify the environment for these actions. User can execute them in a VM in the cloud or on-premises. JavaScript Actions supports Linux, macOS and Windows environment. </p> <p>Example of JavaScript Action <pre><code>    steps:\n        - uses: actions/checkout@v1\n        - name: npm install and build webpack\n        run: |\n          npm install\n          npm run build\n</code></pre></p> <p>JavaScript actions can run directly on the runner machine and separate the action code from the environment that is used to run the action. The action code is simplified and can execute faster that actions within a Docker container. In order to create and use packaged JavaScript Actions, Node.js within the npm should be downloaded. Optional and recommended step would be using GitHub Actions toolkit Node.js, which is a collection of Node.js packages that enables developers to quickly build JavaScript actions with more consistency. Here are the steps to take to build a JavaScript actions:</p> <ol> <li>Create an <code>action.yml</code> metadata file to define the inputs and outputs of the action as well as tell the action runner how to start running this JavaScript action</li> <li>Create an <code>index.js</code> file with context information about the <code>Toolkit packages</code>, <code>routing</code>, and other functions of the action.</li> <li>Commit and push action to GitHub with the following files: <code>action.yml</code>, <code>index.js</code>, <code>node_modules</code>, <code>package.json</code>, <code>package-lock.json</code> and <code>README.md</code>.</li> </ol> </li> <li> <p>Container Actions - there environment is part of the action's code. These Actions can only be run in a Linux environment that GitHub hosts.</p> <p>Example of Container Action <pre><code>    name: \"Hello Actions\"\n    description: \"Greet someone\"\n    author: \"octocat@github.com\"\n\n    # Getting value of a variable called MY_NAME\n    # Variable will be set in the workflow that runs this action\n    inputs:\n        MY_NAME:\n          description: \"Who to greet\"\n          required: true\n          default: \"World\"\n\n    runs:\n        # uses requires the path to the Dockerfile\n        using: \"docker\"\n        image: \"Dockerfile\"\n\n    # Branding personalizes the action in the GitHub Marketplace \n    # if user decides to publish it there\n    branding:\n        icon: \"mic\"\n        color: \"purple\"\n</code></pre> Docker Containers package the environment with the GitHub Actions code. This means that the actions runs in a consistent and reliable environment because all of its dependencies are within that container. If the action needs to run in a specific environment configuration, then Docker containers are a good way to go because you can customize the operating system and tools. It often requires to build and retrieve the container, that is why Docker container actions are slower than JavaScript acctions. In order to start, developer should follow:</p> <ol> <li>Create a <code>Dockerfile</code> to define the commands to assemle the Docker image</li> <li>Create an <code>action.yml</code> metadata file to define the inputs and outputs of the action. Set the <code>runs: using:</code> value to <code>docker</code> and the <code>runs: image:</code> value to <code>Dockerfile</code> in the file.</li> <li>Create an <code>entrypoint.sh</code> file to describe the docker image.</li> <li>Commit and push the action to GitHub with the following files: <code>action.yml</code>, <code>entrypoint.sh</code>, <code>Dockerfile</code>, and <code>README.md</code>.</li> </ol> </li> <li> <p>Composite run actions - this action enable to reuse actions using shell scripts. Developer can mix multiple shell languages within the same action. For example if developer have a multiple shell scripts to automate several tasks, he/she can turn them into action and reuse them for different workflows. Sometimes it's easier to just write a shell script than using JavaScript or wrapping code into a Docker container. Example of composite run action below:</p> <pre><code>name: 'Hello World'\ndescription: 'Greet someone'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  random-number:\n    description: \"Random number\"\n    value: ${{ steps.random-number-generator.outputs.random-number }}\nruns:\n  using: \"composite\"\n  steps:\n    - run: echo Hello ${{ inputs.who-to-greet }}.\n      shell: bash\n    - id: random-number-generator\n      run: echo \"random-number=$(echo $RANDOM)\" &gt;&gt; $GITHUB_OUTPUT\n      shell: bash\n    - run: echo \"${{ github.action_path }}\" &gt;&gt; $GITHUB_PATH\n      shell: bash\n    - run: goodbye.sh\n      shell: bash\n</code></pre> </li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#github-hosted-versus-self-hosted-runners","title":"GitHub Hosted versus self-hosted runners","text":"<ul> <li>A runner is a server that has the GitHub Actions runner application installed. For example <code>runs-on: ubuntu-latest</code> will run using the <code>GitHub-hosted</code> runner that is running in the environment ubuntu-latest. If user uses a GitHub-hosted runner, each job will run in a fresh instance of the virtual environment that is specified in <code>runs-on: {operating system-version}</code> command.</li> <li>A self-hosted runner is a server that user manage himself. In order to use it, user must apply the self-hosted label, it's operating system and the system architecture. For example, a self-hosted runner with a Linux operating system and ARM32 architecture would look like the following, <code>runs-on: [self-hosted, linux, ARM32]</code>.</li> </ul> <p>Each type of runner has its own advantages and disadvantages. For example it is quicker and easier to start with GitHub-hosted runners, but they are not as flexible as self-hosted runners. On the other hand, self-hosted runners are more flexible, but they require more time and effort to set up and maintain.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#metadata-and-syntax-in-order-to-create-an-action","title":"Metadata and syntax in order to create an action","text":"<p>Before creating or reviewing a GitHub action, the first step is to review the <code>action.yml</code> file to assess which inputs, outputs, descritpion, and other configuration information are needed for the action. Some of these parameters are required while other are optional. The table below represents these parameters that the <code>action.yml</code> file should define about the action:</p> Parameter Description Required Name The name of your action. Helps visually identify the action in a job. yes Description A summary of what your action does. yes Runs The command to run when the action executes. yes Inputs Input parameters enable you to specify data that the action expects to use during runtime. These parameters become environment variables in the runner. no Outputs Output parameters enable you to specify data that subsequent actions can use later in the workflow after the action that defines these outputs has run. no Branding Color and Feather icon to use to create a badge to personalize and distinguish your action in GitHub Marketplace. no"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#runs-inputs-outputs-branding","title":"Runs, Inputs, Outputs, Branding","text":""},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#runs-required","title":"Runs (required)","text":"<p><code>runs</code> is a required statement which defines the command necessary to execute the action. Wether it's container, JavaScript or composite run steps action, the <code>runs</code> syntax is defined differently.</p> <ol> <li> <p><code>runs</code> for Docker actions      Docker container action require that the <code>runs</code> statement configures the image used for the Docker action with the following arguments:</p> <ul> <li><code>using</code>: needs to be set to <code>docker</code> to run a Docker container action.</li> <li><code>image</code>: Docker image used as the container to run the action.</li> </ul> <pre><code>runs:\n  using: 'docker'\n  image: 'Dockerfile'\n</code></pre> </li> <li> <p><code>runs</code> for JavaScript actions      JavaScript actions require that the <code>runs</code> statements take the following two arguments:</p> <ul> <li><code>using</code>: application used to execute the code as defined in <code>main</code>.</li> <li><code>main</code>: file that contains the action code. The application defined in <code>using</code> executes this file.</li> </ul> <pre><code>runs:\n  using: 'node12'\n  main: 'main.js'\n</code></pre> </li> <li> <p><code>runs</code> for composite run steps actions      Composite run steps actions require that the <code>runs</code> statement take the following arguments:</p> <ul> <li><code>using</code>: needs to be set to <code>composite</code> to run a composite run step</li> <li><code>steps</code>: run steps to run the action.</li> <li><code>steps[*].run</code>: command you want to run (can be inline or a script in action repository)</li> </ul> <pre><code>runs:\n  using: \"composite\"\n  steps:\n    - run: ${{ github.action_path }}/test/script.sh\n      shell: bash\n</code></pre> </li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#inputs","title":"Inputs","text":"<p>Inputs are the parameters that enable to specify data that the action expects to use during its runtime. GitHub stores these input parameters as environment variables. The example below is a list of inputs for an action. The <code>firstNameStudent</code> input is optional while the <code>studentGrade</code> input is required.</p> <pre><code>inputs:\n  firstNameStudent:\n    description: 'First name of student'\n    required: false\n    default: '1'\n  studentGrade:\n    description: 'Grade of the student'\n    required: true\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#outputs-optional","title":"Outputs (optional)","text":"<p>Outputs are the parameters that enables to declare data. Actions that run later in a workflow can use the output data that was declared in a previosuly ran action. </p> <pre><code>outputs:\n  average:\n    description: 'The average grade of the students'\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/2-About-GitHub-Actions/#branding-optional","title":"Branding (optional)","text":"<p>An optional but fun feature is the ability to customiza the badge of action. The badge is displayed next to the action name in the <code>GitHub Marketplace</code>. The color and Feather icon can be used to create the badge. For branding should be specified the icon and color.</p> <p><pre><code>branding:\n  icon: 'shield'  \n  color: 'blue'\n</code></pre> The example of a badge for the Checkout action on the GitHub Marketplace: </p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/","title":"GitHub Actions CI","text":""},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#github-actions-structure","title":"GitHub Actions Structure","text":"<p>The picture below explains how Github Actions workflow components are working together.</p> <p></p> <p>To simplify what happens in the picture above: <code>An event triggers the workflow, which contains the job. The job contains the steps. The steps contain the actions.</code></p> <p>A GitHub Actions workflow is a process that user sets up in repository to automate software-development lifecycle tasks. In order to create a workflow, user should add actions to a <code>.yml</code> file in the <code>.github/workflows</code> directory of the repository. The basic syntax of setting up an action would look like following:</p> <pre><code>    name: A workflow for my Hello World file\n    on: push\n    jobs:\n      build:\n        name: Hello world action\n        runs-on: ubuntu-latest\n        steps:\n        - uses: actions/checkout@v1\n        - uses: ./action-a\n          with:\n            MY_NAME: \"Mona\"\n</code></pre> <ul> <li><code>on:</code> attribute is a trigger to specify when the workflow will run. In example above workflow executes on <code>push</code> event. </li> <li><code>jobs:</code> attribute is a section that contains different jobs. </li> <li><code>build:</code> is a name of the job. And it usually contain <code>name</code>, <code>runs-on</code> and <code>steps</code> attributes.</li> <li><code>steps:</code> attribute is a section that contains the action steps. </li> <li><code>uses:</code> attribute is a reference to the action. </li> <li><code>with:</code> attribute is a section that contains the inputs for the action.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#workflow","title":"Workflow","text":"<p>A workflow is an automated process that you add to your repository. A workflow <code>needs</code> to have at least one job and can be triggered by different events.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#jobs","title":"Jobs","text":"<p>The job is the first major component within the workflow. Job is a section of the worklfow that will be associated with a runner. A runner can be both: <code>GitHub-hosted</code> or <code>self-hosted</code>, and job can run on a <code>machine</code> or in <code>container</code>. The runner can be specified using <code>runs-on</code> keyword.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#steps","title":"Steps","text":"<p>A step us an individual task that can run commands in a job.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#actions","title":"Actions","text":"<p>The actions are the standalone commands inside the workflow. These commands can reference GitHub actions such as using custom or community actions.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#control-your-workflow","title":"Control your Workflow","text":"<p>It is possible to desable the workflow. It can be stopped from beign triggered though GitHub or REST API. Disabling a workflow can be usiful in situations like:</p> <ul> <li>Workflow is producing a critical error</li> <li>Temporarily pause the workflow due to low priority level and resource consuming</li> <li>Workflow is sending requests to a service that is down</li> <li>While working on a fork and all the functionality is unnecessary. </li> </ul> <p>In order to cancel a workflow run that is in progress, developers can use GitHub UI from the Actions tab or GitHub API endpoint <code>DELETE /repos/{owner}/{repo}/actions/runs/{run_id}</code>.</p>"},{"location":"GitHub%20Actions%20Accreditation/1.%20Introduction/3-GitHub-Actions-Workflow/#organizations-templated-workflow","title":"Organization's templated workflow","text":"<p>GitHub Actions allows organizations to build and maintain workflows for their own needs by creating and reusing workflow templates which supports organization needs. This templates should be defined in organization's <code>.github</code> repository. Any member and repository within the organzation can have an access to these organization workflow templates. Those workflows can be found by navigating to the <code>Actions</code> tab, selecting <code>New workflow</code>, and finding the organization's workflow template section titled \"Workflows created by <code>&lt;organization name&gt;</code>\". For example, the organization called Mona has a template workflow as shown below.</p> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/1.%20Versioning%2C%20Matrix%20and%20Automation/","title":"1. Versioning, Matrix and Automation","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/1.%20Versioning%2C%20Matrix%20and%20Automation/#action-versioning","title":"Action versioning","text":"<p>There are different ways to reference for actions in the workflow. The recommended way by GitHub is to refer to a specific version of the action, rather than just the action itself. By referencing to a specific version, user is placing a safeguard from unexpected changes pushed to the action that could potentially break your workflow. Below is an example of several ways to reference a specific version of an action:</p> <pre><code>steps:    \n  # Reference a specific commit\n  - uses: actions/setup-node@c46424eee26de4078d34105d3de3cc4992202b1e\n  # Reference the major version of a release\n  - uses: actions/setup-node@v1\n  # Reference a minor version of a release\n  - uses: actions/setup-node@v1.2\n  # Reference a branch\n  - uses: actions/setup-node@main\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/1.%20Versioning%2C%20Matrix%20and%20Automation/#matrix-strategy","title":"Matrix Strategy","text":"<ul> <li>Matrix strategy lets users to use variables in a single job definition to automatically create multiple job runs, that are based on the combination of the variables. Fox example, matrix strategy can be used to test the code in multiple versions of a language or on miltiple operation systems.</li> <li>The example below shows how to use a matrix strategy to test a <code>test</code> job in multiple versions of <code>operation systems</code> and <code>Node.js</code>. The <code>steps</code> in this example will run once for each version of <code>Node.js</code> specified in the <code>matrix.node-version</code> array. The <code>matrix</code> variable is available in the <code>steps</code> as <code>${{ matrix.node-version }}</code>. Current example is also suitable for customizing workflow templates.   <pre><code>name: Node.js CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\ntest:\n  runs-on: ${{ matrix.os }}\n  strategy:\n    matrix:\n      os: [ubuntu-lastest, windows-2016]\n      node-version: [8.x, 10.x]\n  steps:\n  - uses: actions/checkout@v1\n  - name: Use Node.js ${{ matrix.node-version }}\n    uses: actions/setup-node@v1\n    with:\n      node-version: ${{ matrix.node-version }}\n  - name: npm install, and test\n    run: |\n      npm install\n      npm test\n    env:\n      CI: true\n</code></pre></li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/1.%20Versioning%2C%20Matrix%20and%20Automation/#automation","title":"Automation","text":"<ul> <li>If developer want to run the workflow after a reviewer has approved the pull request, he/she can use the <code>pull_request_review</code> event.</li> <li>Another option is to add a label to the pull request like in example below:   <pre><code>steps:\n  - name: Label when approved\n    uses: pullreminders/label-when-approved-action@main\n    env:\n      APPROVALS: \"1\"\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      ADD_LABEL: \"approved\"\n</code></pre></li> <li>The <code>env:</code> block is where you set the environment variables for this action. For example it can be the number of approvers needed.</li> <li>Notice the <code>GITHUB_TOKEN</code>. In order to do changes to the repository, the token must be provided with needed scope.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/2.%20Conditional-statement/","title":"2. Conditional statement","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/2.%20Conditional-statement/#conditional-keywords","title":"Conditional keywords","text":"<ul> <li> <p>Developers can use and evaluate expressions. Expressions are commonly used with the conditional <code>if</code> keyword to determine whether or not a step should run. The following example shows how to use the <code>if</code> keyword to run a step only when the <code>github.event_name</code> is <code>push</code>:     <pre><code>    steps:\n      - name: Run a one-line script\n        if: github.event_name == 'push'\n        run: echo \"A ${{ github.event_name }} event occurred.\"\n</code></pre></p> <p>Other example uses the <code>if</code> keyword to run a step only when the <code>github.ref</code> (the <code>branch</code> or <code>tag</code> ref that triggered the workflow run) matches <code>refs/heads/main</code>: <pre><code>    name: CI\n    on: [push]\n    jobs:\n      prod-check:\n        if: github.ref == 'refs/heads/main'\n        runs-on: ubuntu-latest\n          steps:\n            - name: Run a one-line script\n              run: echo \"The ref is ${{ github.ref }}.\"\n              ...\n</code></pre></p> <p><code>It's important to know that when using conditionals in your workflow, you need to use the specific syntax ${{ &lt; expression &gt; }}, which tells GitHub to evaluate an expression rather than treat it as a string.</code></p> </li> <li> <p>In order to run a workflow with more specific conditional, GitHub offers using a keyword like containes(), startsWith(), endsWith(), and more. For example the in order to execute workflow workflow if a 'stage' label is added to the pull request would be:    <pre><code>  if: contains(github.event.pull_request.labels.*.name, 'stage')\n</code></pre></p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/2.%20Conditional-statement/#note","title":"Note!","text":"<p>When it comes to variables, contitional keyword can be used only within the context variables or predefined workflow variables inside the <code>env:</code> attribute! More about it in next chapter: <code>Variables</code></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/3.%20Variables/","title":"3. Variables","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/3.%20Variables/#default-environment-variables-contexts-and-custom-variables","title":"Default environment variables, Contexts and Custom variables","text":"<p>Within the GitHub Actions workflow, there are several default environment variables that are available for you to use, but only within the runner that's executing a job. It is recommended to use default environment variables to reference the filesystem rather than using hard-coded file paths. For using default environment variable specify <code>$</code> followed by variable name.</p> <ul> <li>The following environment variables are available by default in all workflows:</li> <li><code>GITHUB_WORKFLOW</code> - The name of the workflow.</li> <li><code>GITHUB_ACTION</code> - The unique identifier (ID) of the action.</li> <li><code>GITHUB_ACTOR</code> - The name of the person or app that initiated the workflow. For example, <code>octocat</code>.</li> <li><code>GITHUB_REPOSITORY</code> - The owner and repository name. For example, <code>octocat/Hello-World</code>.</li> <li><code>GITHUB_EVENT_NAME</code> - The name of the webhook event that triggered the workflow. For example, <code>push</code> or <code>pull_request</code>.</li> <li><code>GITHUB_EVENT_PATH</code> - The path of the file with the complete webhook event payload. For example, <code>/github/workflow/event.json</code>.</li> <li><code>GITHUB_WORKSPACE</code> - The GitHub workspace directory path. The workspace directory contains a subdirectory with a copy of your repository if your workflow uses the <code>actions/checkout</code> action. If you don't use the <code>actions/checkout</code> action, the directory will be empty. For example, <code>/home/runner/work/my-repo-name/my-repo-name</code>.</li> <li><code>GITHUB_SHA</code> - The commit SHA that triggered the workflow. For example, <code>ffac537e6cbbf934b08745a378932722df287a53</code>.</li> <li><code>GITHUB_REF</code> - The branch or tag ref that triggered the workflow. For example, <code>refs/heads/feature-branch-1</code>. If neither a branch or tag is available for the event type, the variable will not exist.</li> <li><code>GITHUB_HEAD_REF</code> - Only set for forked repositories. The branch of the head repository.</li> <li><code>GITHUB_BASE_REF</code> - Only set for forked repositories. The branch of the base repository.</li> </ul> <p>In addition to default environment variables, you can use defined variables as contexts. Contexts and default variables are similar in that they both provide access to environment information, but they have some important differences. While default environment variables can only be used within the runner, context variables can be used at any point within the workflow. For example, context variables allow you to run an <code>if</code> statement to evaluate an expression before the runner is executed.</p> <ul> <li>The example below is using <code>github.ref</code> as a context variable:</li> </ul> <pre><code>name: CI\non: push\njobs:\n  prod-check:\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploying to production server on branch $GITHUB_REF\"\n</code></pre> <p>Custom evironment variables can be used in workflow. In order to create custom variable, user should define it in workflow file using the <code>env</code> context. I variable must be used inside a runner, it can use the runner operating system's normal method for reading environment variables. - See an example below:</p> <pre><code>name: CI\non: push\njobs:\n  prod-check:\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Nice work, $First_Name. Deploying to production server on branch $GITHUB_REF\"\n        env:\n          First_Name: Mona\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/4.%20Events/","title":"4. Events","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/4.%20Events/#scheduled-events","title":"Scheduled events","text":"<ul> <li> <p>The <code>schedule</code> event allows developers to trigger a workflow to run at specific UTC times using POSIX cron syntax. The following example shows how to run a workflow every day at 15:00 UTC.</p> <pre><code>    name: A workflow for my Hello World file\n    on:\n      schedule:\n        - cron:  '*/15 * * * *'\n    jobs:\n      build:\n        name: Hello world action\n        runs-on: ubuntu-latest\n        steps:\n        - uses: actions/checkout@v1\n        - uses: ./action-a\n          with:\n            MY_NAME: \"Mona\"\n</code></pre> <p>And workflow below runs on every Sunday at 3:00am:</p> <pre><code>    on:\n      schedule:\n        - cron:  '0 3 * * SUN'\n</code></pre> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/4.%20Events/#manual-events","title":"Manual events","text":"<ul> <li> <p>Developer is able to manually trigger a workflow by using the <code>workflow_dispatch</code> event. This event allows developers to run the workflow using the GitHub REST API or by selecting the Run workflow button in the Actions tab within your repository on GitHub. Using <code>workflow_dispatch</code>, developer can choose on which branch he want the workflow to run, as well as set optional inputs that <code>GitHub</code> will present as form elements in the <code>UI</code>. The following example shows how to manually trigger a workflow by using the GitHub Actions tab in the repository.</p> <pre><code>    on:\n      workflow_dispatch:\n        inputs:\n          logLevel:\n            description: 'Log level'     \n            required: true\n            default: 'warning'\n          tags:\n            description: 'Test scenario tags'\n</code></pre> </li> <li> <p>In addition to <code>workflow_dispatch</code>, developer can use the <code>GitHub API</code> to trigger a <code>webhook</code> event called <code>repository_dispatch</code>. This event allows developer to trigger a workflow for activity that occurs outside of GitHub, and essentially serves as an <code>HTTP</code> request to repository asking <code>GitHub</code> to <code>trigger</code> a <code>workflow</code> off an action or webhook. Using this manual event requires developer to do two things:</p> <ul> <li>send a POST request to the GitHub endpoint /repos/{owner}/{repo}/dispatches with the webhook event names in the request body </li> <li>configure your workflow to use the repository_dispatch event.</li> <li>The following example shows how to manually trigger a workflow by using the GitHub API. <pre><code>    on:\n      repository_dispatch:\n        types: [opened, deleted]\n</code></pre> <pre><code>    curl \\\n-X POST \\\n-H \"Accept: application/vnd.github.v3+json\" \\\nhttps://api.github.com/repos/octocat/hello-world/dispatches \\\n-d '{\"event_type\":\"event_type\"}'\n</code></pre></li> </ul> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/4.%20Events/#workflow-run-using-webhook-events","title":"Workflow run using webhook events","text":"<ul> <li>As said above, developers can configure a workflow to run when a specific event occurs on the GitHub. Most webhook events can be triggered from more than one activity for a webhook. Developers can specify an activity type to trigger the workflow. For example, developer can run a workflow for the <code>check_run</code> event, but only for the <code>rerequested</code> or <code>requested_action</code> activity types:     <pre><code>    on:\n      check_run:\n        types: [rerequested, requested_action]\n</code></pre></li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/5.%20Keywords/","title":"5. Keywords","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/5.%20Keywords/#run-keyword","title":"Run keyword","text":"<p>The <code>run</code> keyword is used to execute the task. <code>run</code> keyword tells the job to execute a command on the runner. This keyword can be used to execute actions or script. For example in the snippet below, the <code>run</code> keyword executes the script called <code>build.sh</code>, which is defined inside the <code>./github/scripts/</code> directory. <pre><code>jobs:\n  example-job:\n    steps:\n      - name: Run build script\n        run: ./.github/scripts/build.sh\n        shell: bash\n</code></pre></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/6.%20Cache%20and%20Artifacts/","title":"6. Using Cache and Artifacts","text":"<p>GitHub is providing two main ways to reuse dependencies between workflow: using <code>cache</code> or <code>artifacts</code>. <code>Caching</code> is a feature that allows you to persist files across workflow runs. It is useful for storing dependencies, build outputs, or other files that are generated during the workflow that users want to reuse in future runs. For example, it can be used to <code>cache</code> a <code>node_modules</code> directory in <code>Node.js</code> project to reduce the amount of time it takes to install dependencies during subsequent runs.</p> <p>The main difference between <code>artifacts</code> and <code>caches</code> is that artifacts are <code>files</code> or <code>directories</code> that should be persisted after the workflow run has completed. They can be used to share files between different <code>jobs</code> in a workflow, or to persist files for later use, such as <code>downloading</code> and <code>storing</code> the build <code>artifacts</code> for deployment. Unlike <code>cache</code>, by default artifacts are stored and <code>accessible</code> for 90 days after a workflow run has completed. That means, that the main difference between <code>caching</code> and <code>artifacts</code> is that caching is used to <code>persist</code> files <code>during</code> the workflow run, while artifacts are used to persist files <code>after</code> the workflow run has completed. <code>Caching</code> is more focused on improving performance, while <code>artifacts</code> are more focused on sharing files between jobs and workflows.</p> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/6.%20Cache%20and%20Artifacts/#using-cache","title":"Using Cache","text":"<p>In order to cache dependencies for a job, user will need to use GitHub's <code>cache</code> action. This action retrieves a cache identified by a unique key that user provide. After action successfully finds the cache, it retrieves the cached files to the path that user configure. In order to use the cache, user must set a few specific parameters:</p> <code>Parameter</code> <code>Description</code> <code>Required</code> <code>Key</code> Refers to the key identifier created when saving and searching for a cache. Yes <code>Path</code> Refers to the file path on the runner to cache or search. Yes <code>Restore-keys</code> Consists of alternative existing keys to caches if the desired cache key is not found. No <p><pre><code>steps:\n  - uses: actions/checkout@v2\n\n  - name: Cache NPM dependencies\n    uses: actions/cache@v2\n    with:\n      path: ~/.npm\n      key: ${{ runner.os }}-npm-cache-${{ hashFiles('**/package-lock.json') }}\n      restore-keys: |\n        ${{ runner.os }}-npm-cache-\n</code></pre> In the preceding example, the path is set to ~/.npm and the key includes the runner's operating system and the SHA-256 hash of the package-lock.json file. Prefixing the key with an ID (npm-cache in this example) is useful when you are using the restore-keys fallback and have multiple caches.</p> <p></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/6.%20Cache%20and%20Artifacts/#using-artifacts","title":"Using Artifacts","text":"<ul> <li>When a workflow produces something other than a log entry, it's called an artifact. For example, the Node.js build will produce a Docker container that can be deployed. </li> <li>This artifact can be: <ul> <li>uploaded to storage by using the action <code>actions/upload-artifact</code> </li> <li>downloaded from storage by using the action <code>actions/download-artifact</code></li> </ul> </li> <li>Storing an artifact helps to preserve it between jobs. </li> <li>Each job uses a fresh instance of a VM. Developers can't reuse the artifact by saving it on the VM.</li> <li>In order to use artifacts, developer should upload the artifact storate in one job and download it for the other job.</li> <li>The following example shows how to upload an artifact to storage by using the <code>actions/upload-artifact</code> action:   <pre><code>name: Upload Artifact\non: push\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Upload Artifact\n      uses: actions/upload-artifact@v2\n      with:\n        name: my-artifact\n        path: ./path/to/file\n</code></pre></li> <li>The following example shows how to download an artifact from storage by using the <code>actions/download-artifact</code> action:   <pre><code>name: Download Artifact\non: push\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Download Artifact\n      uses: actions/download-artifact@v2\n      with:\n        name: my-artifact\n</code></pre></li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/6.%20Cache%20and%20Artifacts/#artifact-storage","title":"Artifact storage","text":"<ul> <li>Artifacts are stored in storage space on GitHub. The space is <code>free</code> for public repositories and some amount is free for private repos, depending on the account. GitHub stores artifacts for <code>90 days</code>.</li> <li>In <code>ationcs/upload-artifact@main</code> is a <code>path:</code> attribute. This is the path to store the artifact. If the path is a directory, the entire directory is stored as an artifact. If the path is a file, only that file is stored as an artifact. Workflow example:   <pre><code>build:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v1\n    - name: npm install and build webpack\n      run: |\n        npm install\n        npm run build\n    - uses: actions/upload-artifact@main\n      with:\n        name: webpack artifacts\n        path: public/\n</code></pre></li> <li>To download the artifact for testing, the build must have completed successfully and uploaded the artifact. </li> <li>Following code specify that the test job depends on the build job:   <pre><code>test:\n  needs: build\n  runs-on: ubuntu-latest\n</code></pre></li> <li>Following snippet downloads the artifact and stores it in the <code>public</code> directory:   <pre><code>steps:\n  - uses: actions/checkout@v1\n  - uses: actions/download-artifact@v2\n    with:\n      name: webpack artifacts\n      path: public/\n</code></pre></li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/6.%20Cache%20and%20Artifacts/#passing-artifact-between-jobs","title":"Passing artifact between jobs","text":"<p>Similar to the idea of caching dependencies, it is possible to pass data between jobs within the same workflow using cache. User can achieve it by using <code>actions/upload-artifact</code> and <code>actions/download-artifact</code> actions. Jobs that are dependent on ap previous job's artifacts must wait for the dependent job to complete successfu\u00f6\u00f6y before they can run. This is useful if developer have a series of jovs that need to run sequentially on artifacts uploaded from a previous job. In the following example job_2 requires job_1 by using <code>needs: job_1</code> syntax. <code>job_1</code> creates a file.txt and uploads it as an artifact. <code>job_2</code> downloads the artifact and prints the contents of the file.txt to the console:</p> <pre><code>name: Share data between jobs\non: push\njobs:\n  job_1:\n    name: Upload File\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Hello World\" &gt; file.txt\n      - uses: actions/upload-artifact@v2\n        with:\n          name: file\n          path: file.txt\n\n  job_2:\n    name: Download File\n    runs-on: ubuntu-latest\n    needs: job_1\n    steps:\n      - uses: actions/download-artifact@v2\n        with:\n          name: file\n      - run: cat file.txt\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/7.%20Debugging/","title":"7. Debugging","text":""},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/7.%20Debugging/#debug-logging-in-a-workflow","title":"Debug logging in a workflow","text":"<p>Default workflow logs might not provide enough detail to diagnose the reason of specific workflow run failure. In order to get more debug logging user must enable additional logging for two options: <code>runs</code> and <code>steps</code>. User can enable additional logging by setting some repository secrets that require <code>admin</code> access to the repository to <code>true</code>. Below are the two options: - enable runner diagnostic logging: set <code>ACTIONS_RUNNER_DEBUG</code> secret in the repository that contains the workflow to <code>true</code> - enable step debug logging: set <code>ACTIONS_STEP_DEBUG</code> secret in the repository that contains the workflow to <code>true</code></p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/7.%20Debugging/#access-the-workflow-logs-from-the-user-interface","title":"Access the workflow logs from the user interface","text":"<p>Debugging process can be frustration, however GitHub provides a clear way to navigate between the jobs while keeping the context of the currently debugging step. To review the logs, follow the steps below:</p> <ol> <li>Navigate to the <code>Actions</code> tab in your repository.</li> <li>In the left sidebar, click the desired workflow.</li> <li>From the list of workflow runs, select the desired run.</li> <li>Under <code>Jobs</code>, select the desired job.</li> <li>Read the log output.</li> </ol> <p>There is also an option to set change of the <code>Status</code> filter. For example after choosing the workflow and setting it to <code>Failure</code>, it will only display the failed runs within that workflow.</p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/7.%20Debugging/#access-the-workflow-logs-from-the-rest-api","title":"Access the workflow logs from the REST API","text":"<p>In order to access the workflow logs from the REST API, user must use the <code>GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs</code> endpoint. This endpoint will return the logs for a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private, access token with the <code>repo</code> scope is required.</p>"},{"location":"GitHub%20Actions%20Accreditation/2.%20GitHub%20Actions%20Syntax/7.%20Debugging/#workflow-commands","title":"Workflow commands","text":"<p>Workflow commands can add another level of customization for the workflow. Workflow commands enables communication with the GitHub Actions runner machine by printing formatted lines of text to the console. These workflow commands can be used with shell commands or within custom actions. These commands are useful to share information between steps, pring debug or error messages to the console, set environment variables, set output parameters or add to the system path. Most workflow commands use the <code>echo</code> command in the below specific format, while other can be invoked by writing to a file.</p> <pre><code>    echo \"::workflow-command parameter1={data},parameter2={data}::{command value}\"\n</code></pre> <ul> <li> <p>The basic logging examples for printing a debug, info, error, or warning message to the console:</p> <pre><code>    - name: workflow commands logging messages\n      run: |\n        echo \"::debug::This is a debug message\"\n        echo \"This is an info message\"\n        echo \"::error::This is an error message\"\n        echo \"::warning::This is a warning message\"\n</code></pre> </li> <li> <p>It is also possible to create a message to print to the console with a filename (file), line number (line), and column number (col). This is useful for printing error messages from a linter or compiler:</p> <pre><code>    echo \"::error file=app.js,line=10,col=15::Something went wrong\"\n</code></pre> </li> <li> <p>It's important to note that these workflow commands need to be on a single line. Characters that interfere with parsing such as commas and line breaks will need to be URL-encoded. For example, the following multi-line message:</p> <pre><code>This text spans\nacross multiple lines\n</code></pre> </li> <li> <p>Should be encoded as shown below:</p> <pre><code>This text spans%0Aacross multiple lines\n</code></pre> </li> <li> <p>In addition to workflow commands, there is a possibility yo set exit codes to set the status of an action. This is important, because it allows to exit from a failed job with a code, halt all concurrent actions and cabcek any future actions. With JavaScript actions, there is a toolkit called <code>@actions/core</code> to log a message and set a failure exit code. For Docker container, developer should set a failure message and exit code in the <code>entrypoint.sh</code> file. For example:</p> <pre><code>echo \"::error::Something went wrong!\"\nexit 1\n</code></pre> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/1.%20Package%20Registries/","title":"GitHub Package Registries","text":"<p>GitHub Packages is a package-managemenet service that simplifies the process of publishing and consuming packages. GitHub Packages allow users to use, share or find public or private project dependencies within their organization or repositories.</p> <p>GitHub Packages is compatible with common package-management clients. GitHub Packages supports following package-management clients:</p> <ul> <li>npm</li> <li>NuGet</li> <li>Maven and Gradle</li> <li>RubyGems</li> </ul> <p>Github Packages is also a container registry. It allows users to store, manage, and deploy container images. It is compatible with Docker and Kubernetes. Once image is published (in public or in private), it allows to use these images from anywhere, including:</p> <ul> <li>Local development environment</li> <li>As a base image from GitHub Codespaces development environment</li> <li>As a step to execute into CI/CD workflow with GitHub Actions</li> <li>On a server or a cloud service</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/1.%20Package%20Registries/#github-packages-vs-github-releases","title":"GitHub Packages vs GitHub Releases","text":"<p>GitHub Packages are used to publish release of libraries to a standard package feed or a container registry. They are meant to leverage the ways the specific package-management client works with that feed, like linking back to the repository in which the package was created as well as the version of the code that was used.</p> <p>GitHub Releases are used to release a bundle of packaged software, along with the release notes and links to binary files. Those releases can be directly downloaded from their unique URL and tracked back to specific commit they were created from. Users can download the release as tarball or zip file.</p> <p>For example if user using both: JavaScript (npm) and Java (Maven) in project, user should maintain three different sets of user permissions: Git, npm and Maven. Using GitHub Packages, user can manage all of those permissions in one place across source-code repository, private npm repository and Maven or Grandle private repository. Packages published through GitHub inherit the visibility and permissions assigned at the repository level. A new team member needs read access to a package and its code? Give them read access to the repository and it's done!</p>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/1.%20Package%20Registries/#workflow-to-publish-to-github-packages","title":"Workflow to publish to GitHub Packages","text":"<p>By combining GitHub Actions and GitHub Packages, developer can build workfllow that will build, test and publish it to GitHub Packages by simply pushing code to the repository.</p> <pre><code>name: Node.js Package\n\non:\n  release:\n    types: [created]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v1\n        with:\n          node-version: 12\n      - run: npm ci\n      - run: npm test\n\n  publish-gpr:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v1\n        with:\n          node-version: 12\n          registry-url: https://npm.pkg.github.com/\n      - run: npm ci\n      - run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}\n</code></pre> <p>The workflow above exists in the <code>.github/workflows</code> directory. The common naming practice for this action is <code>release-package.yml</code>.</p>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/1.%20Package%20Registries/#github-container-registry-to-host-and-manage-docker-container-images","title":"GitHub Container Registry to host and manage Docker container images","text":"<p>As been mentioned, GitHub Packages support the use of containers, Kubernetes and other cloud-native technologies to manage their entire application lifecycle including production operations, development, release, and deployment. With container registry users can:</p> <ul> <li>Store container images within organization and user account rather than a repository.</li> <li>Set fine-grained permissions for the container images.</li> <li>Access public container images anonymously.</li> </ul> <p>In order to do so user needs to:</p> <ol> <li>Build the image</li> <li>Authenticate and sign in to the GitHub Container Registry service called <code>ghcr.io</code></li> <li>Tag the image </li> <li>Push the latest version of the container registry using following commands:     <pre><code>echo $GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin\ndocker tag IMAGE_ID ghcr.io/OWNER/IMAGE_NAME:latest\ndocker push ghcr.io/OWNER/IMAGE_NAME:latest\n</code></pre></li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/2.%20GitHub%20Packages%20for%20code%20packages/","title":"GitHub Packages for code packages","text":"<p>The way to authenticate into package manager will depend on project's ecosystem. There are only three pieces of information needed:</p> <ul> <li>Personal GitHub username</li> <li>A Personal Access Token (PAT)</li> <li>The GitHub Packages endpoint for package ecosystem</li> </ul> <p>PAT can be generated in users profile settings.</p>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/2.%20GitHub%20Packages%20for%20code%20packages/#log-in-to-github-packages","title":"Log in to GitHub Packages","text":"<ul> <li>In order to publish or install from GitHub Packages, authentication is required. The endpoint for GitHub Packages is <code>https://PACKAGE_TYPE.pkg.github.com/OWNER/REPOSITORY</code>, where <code>PACKAGE_TYPE</code> is the type of package ecosystem username is using. The following table shows the commands to run in order to authenticate to GitHub Packages for each package ecosystem:</li> </ul> Package Ecosystem Command NuGet dotnet nuget add source https://nuget.pkg.github.com/OWNER/index.json -n github -u OWNER -p [Your PAT Token] npm bash npm login --registry=https://npm.pkg.github.com RubyGems echo \":github: Bearer GH_TOKEN\" &gt;&gt; ~/.gem/credentials Maven &amp; Grandle Can be directly authenticated while pushing <p>More information about GitHub Packages</p> <p>When user is authenticated, he/she can easily use published packages in own projects. Each package home page shows the command to run, depending on project environment.</p>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/2.%20GitHub%20Packages%20for%20code%20packages/#managing-packages","title":"Managing packages","text":"<ul> <li> <p>GitHub Packages offer several ways to manage packages lifecycle and workflows. GitHub Packages can be managed through the GitHub API and the GraphQL API. APIs allows to support advanced integrations scenarios. </p> </li> <li> <p>For example GitHub's Webhook feature allows to run code when a new package is published. With webhooks allows to automatically publish a new Tweet or a blog post when a new package is published.</p> </li> <li> <p>GitHub Actions can be used to automate package management. For example <code>delete-package-versions</code> action can automatically prune the oldest version of packages while publishing a new version.</p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/3.%20Publish%20custom%20actions/","title":"Publish a custom GitHub action","text":""},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/3.%20Publish%20custom%20actions/#choose-a-location-and-visibility-for-the-action","title":"Choose a location and visibility for the action","text":"<ul> <li>When creating an action, decide on its visibility: <code>public</code> or <code>private</code> and where it will be hosted. </li> <li>Public actions need their own repository for:<ol> <li><code>versioning</code></li> <li><code>tracking</code> </li> <li><code>discoverability</code> </li> </ol> </li> <li>Private actions can be stored in any location in the same repository. </li> <li>Regardless of visibility, it's a good practice to include well done documentation as a <code>README.md</code> file, covering the action's: <ol> <li><code>description</code></li> <li><code>required</code> &amp; <code>optional</code> </li> <li><code>input</code> &amp; <code>output</code> arguments </li> <li><code>secrets</code> </li> <li><code>environment variables</code> used </li> <li>an example of how to use it. </li> </ol> </li> <li>The <code>README.md</code> should provide all the information a user needs to use the action.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/3.%20Publish%20custom%20actions/#versioning-and-release-practice","title":"Versioning and release practice","text":"<ul> <li> <p>When developing an action, it's important to define a <code>release management strategy</code>, including <code>versioning</code> recommendations to control how updates are distributed. Major version updates including necessary critical fixes, changes and security patches that affect compatibility needs to be documented clearly. Good release managemend strategy should include versioning recommendations. User should bot be referencing an action's default branch with the action as the default branch which is likely to contain the latest code (which may be unstable) and could result broken workflow. </p> </li> <li> <p>Tags are a good option, user can call an action with adding these to the end of the action: </p> <ol> <li><code>major version</code></li> <li><code>patch version</code></li> <li>Target a <code>tag</code>, </li> <li><code>commit SHA</code>, or specific <code>branch</code> name for a release when using the action.</li> </ol> <pre><code>steps:\n    - uses: actions/javascript-action@v1\n    - uses: actions/javascript-action@v1.0.1\n    - uses: actions/javascript-action@v1-beta\n    - uses: actions/javascript-action@2522385f6f7ba04fe7327647b213799853a8f55c\n</code></pre> </li> <li> <p>To effectively manage the releases and versions of software, it is recommended to create a <code>separate</code> branch for <code>releases</code> and test the <code>release</code> on that branch before creating a release tag. </p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/3.%20Package%20Registries%20and%20Custom%20Actions/3.%20Publish%20custom%20actions/#publishing-to-github-marketplace","title":"Publishing to GitHub Marketplace","text":"<ul> <li>In order to share an action with the GitHub community, it can be published to the GitHub Marketplace and reached out to millions of GitHub users.</li> <li>Actions published to the GitHub Marketplace are published immediately if all of the requirements are met. Actions that do not meet the requirements will need to be reviewed by GitHub before being published.</li> <li>The repository for the action should only include the <code>metadata</code> file, <code>code</code>, and <code>files</code> necessary for the action. This makes it easier to <code>tag</code>, <code>release</code>, and <code>package</code> the code in a single unit.</li> <li>The action must be in a public repository and must contain a single action.</li> <li>The action's <code>metadata</code> file (action.yml) must be in the root directory of the repository and the name in the <code>metadata</code> file must be unique on the GitHub Marketplace.</li> <li> <p>The name cannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. The name also cannot match an existing GitHub Marketplace category or feature.</p> </li> <li> <p>Action can be added to GitHub Marketplace by tagging it as a new release and then publishing it. GitHub provides guided steps to help with publishing the release.</p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/1.%20GitHub%20Secrets/","title":"Storing credentials with GitHub Secrets","text":"<p>GitHub Secrets is a secure place to store sensitive data that workflow needs. For example in order to deploy to an Azure resource, the GitHub Action must have permission to access the resource. The example below shows, the location of GitHub Secrets portal: </p> <p>Example below is using credentials stored inside GitHub Secrets using <code>creds:</code> attribute of an Azure <code>login</code> Action:</p> <pre><code>steps:\n      - name: \"Login via Azure CLI\"\n        uses: azure/login@v1\n        with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n</code></pre>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/2.%20Deploying%20to%20Microsoft%20Azure/","title":"Deploying to Microsoft Azure using GitHub Actions","text":"<p>The GitHub Marketplace has several actions that help to automate Azure-related tasks. To find needed Action:</p> <ol> <li>Inside repository, browse to the workflow file that needs to be edited.</li> <li>Click the Edit icon in the upper right corner of the file view.</li> <li>Use the GitHub Marketplace sidebar to the right of the editor to browse Actions.</li> </ol> <p>For example these actions will help to deploy a container-based web app to Azure Web Apps:</p> <ul> <li><code>azure/webapps-container-deploy@v1</code></li> <li><code>azure/login@v1</code></li> <li><code>azure/docker-login@v1</code></li> </ul> <p>For example job that adds these actions to the <code>Deploy-to-Azure</code> would look like: <pre><code>Deploy-to-Azure:\n    runs-on: ubuntu-latest\n    needs: Build-Docker-Image\n    name: Deploy app container to Azure\n    steps:\n      - name: \"Login via Azure CLI\"\n        uses: azure/login@v1\n        with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n      - uses: azure/docker-login@v1\n        with:\n          login-server: ${{env.IMAGE_REGISTRY_URL}}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Deploy web app container\n        uses: azure/webapps-container-deploy@v1\n        with:\n          app-name: ${{env.AZURE_WEBAPP_NAME}}\n          images: ${{env.IMAGE_REGISTRY_URL}}/${{ github.repository }}/${{env.DOCKER_IMAGE_NAME}}:${{ github.sha }}\n\n      - name: Azure logout\n        run: |\n          az logout\n</code></pre></p> <ul> <li> <p><code>needs</code> attribute in the <code>Deploy-to-Azure</code> action refers to the <code>Build-Docker-Image</code> job, which means that this action depends on the successful completion of the Build-Docker-Image job. It does not automatically pass the built image as an artifact.</p> </li> <li> <p><code>runs-on</code> attribute specifies a new instance (in this case, <code>ubuntu-latest</code>) for this job to run on, which means that the <code>Docker</code> image built in the previous job may not be available in the new instance.</p> </li> <li> <p>In order to make the image available to this job, it is essential to either use a <code>registry</code> to store the image or pass it as an <code>artifact</code> between jobs.</p> </li> <li> <p>The <code>azure/docker-login</code> action is being used to authenticate with the container registry and make the image available for deployment in the <code>azure/webapps-container-deploy</code> action that follows.</p> </li> <li> <p>In this particular case the image is probably being pushed to a container registry and then pulled in the <code>Deploy-to-Azure</code> job using the <code>azure/webapps-container-deploy</code> action. This one is catchy, because it doesn\u2019t show any <code>pull</code> or <code>push</code> related syntax. After successful authentication, this action <code>pulls</code> an image and when <code>pushes</code> to the specified container registry.  </p> </li> <li> <p>The login-server attribute is set to <code>${{env.IMAGE_REGISTRY_URL}}</code>, which should refer to the URL of the container registry that was used to store the image.</p> </li> <li> <p>It is not necessary to pass the image as an <code>artifact</code> from the <code>Build-Docker-Image</code> job to the <code>Deploy-to-Azure</code> job, as long as the image is pushed to a registry and can be pulled from there in the <code>Deploy-to-Azure</code> job.</p> </li> <li> <p>Inside <code>azure/webapps-container-deploy</code> action:</p> <ul> <li>images: <code>bash ${{env.IMAGE_REGISTRY_URL}}/${{ github.repository }}/${{env.DOCKER_IMAGE_NAME}}:${{ github.sha }}</code></li> </ul> </li> <li> <p>The <code>azure/webapps-container-deploy</code> action is used to deploy a container image to an Azure Web App, and it does this by pulling the image from a container registry specified in the images parameter.</p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/3.%20Create%20and%20delete%20Azure%20resources/","title":"Create and delete Azure resources by using GitHub Actions","text":"<ul> <li>GitHub Actions can automate creating or taking down the environments users deploy to. </li> <li> <p>For example it might be a good practice to create a job with two different conditionals like 'spin up environment' and 'destroy environment' that can be controlled by using labels: <pre><code>jobs:\n  set-up-azure-resources:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'spin up environment')\n    ...\n\n  destroy-azure-resources:\n    runs-on: ubuntu-latest\n    if: contains(github.event.pull_request.labels.*.name, 'destroy environment')\n    ...\n</code></pre></p> </li> <li> <p>This job is using the <code>Azure CLI</code> to create and destroy the Azure resources. Here is an example of the steps in the <code>set-up-azure-resources</code> job: <pre><code>steps:\n  - name: Checkout repository\n    uses: actions/checkout@v2\n\n  - name: Azure login\n    uses: azure/login@v1\n    with:\n      creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n  - name: Create Azure resource group\n    if: success()\n    # Creating an azure group\n    run: |\n      az group create --location ${{env.AZURE_LOCATION}} --name ${{env.AZURE_RESOURCE_GROUP}} --subscription ${{secrets.AZURE_SUBSCRIPTION_ID}}\n  - name: Create Azure app service plan\n    if: success()\n    # Creating Appservice plan\n    run: |\n      az appservice plan create --resource-group ${{env.AZURE_RESOURCE_GROUP}} --name ${{env.AZURE_APP_PLAN}} --is-linux --sku F1 --subscription ${{secrets.AZURE_SUBSCRIPTION_ID}}\n  - name: Create webapp resource\n    if: success()\n    # Creating a webapp\n    run: |\n      az webapp create --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --plan ${{ env.AZURE_APP_PLAN }} --name ${{ env.AZURE_WEBAPP_NAME }}  --deployment-container-image-name nginx --subscription ${{secrets.AZURE_SUBSCRIPTION_ID}}\n  - name: Configure webapp to use GitHub Packages\n    # Setting up a config container\n    if: success()\n    run: |\n      az webapp config container set --docker-custom-image-name nginx --docker-registry-server-password ${{secrets.GITHUB_TOKEN}} --docker-registry-server-url https://docker.pkg.github.com --docker-registry-server-user ${{github.actor}} --name ${{ env.AZURE_WEBAPP_NAME }} --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --subscription ${{secrets.AZURE_SUBSCRIPTION_ID}}\n</code></pre></p> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/4.%20Remove%20artifacts%2C%20create%20status%20badges%2C%20and%20configure%20environment%20protections/","title":"Remove artifacts, create status badges, and configure environment protections","text":""},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/4.%20Remove%20artifacts%2C%20create%20status%20badges%2C%20and%20configure%20environment%20protections/#remove-workflow-artifacts-from-github","title":"Remove workflow artifacts from GitHub","text":"<p>By default GitHub stores any build logs and uploaded artifacts for 90 days before they are deleted. The retention period is customizable based on the type of repository and the usage limits are set for GitHub product. </p> <ul> <li>For example if organization is reaching storage limit for GitHub artifacts and packages and management wants to remove old artifacts without increasing usage limits and blocking workflows, the solution would be to reclaim used GitHub Actions storage by deleting artifacts before they expire on GitHub. This can be done in two ways:  <code>Note</code>:  Both methods require write access to the repository! <ol> <li>Manually deleting artifacts from repository<ul> <li>To manually delete an artifact on GitHub, it requires to navigate to the <code>Actions tab</code>, selectiong the workflow from the left sidebar and then selecting the needed run.</li> <li>Under <code>Artifacts</code>, delete the artifact which should be removed.</li> <li>This procedure can also be completed using the <code>Artifacts REST API</code>. This API allows downloading and retrieving information about work artifacts.</li> </ul> </li> <li> <p>Change the default retention period</p> <ul> <li>The default artifact and log retention peroud for repository, organization or enterprise accound can be changed.</li> <li>Changing the tetention period will only apply to new artifacts and log files, and does not apply to existing objects.</li> <li> <p>The process to configure these settings is a bit different for repository, organization or enterprise:</p> <ul> <li>Configuring the retention period for GitHub Actions artifacts and logs in your repository</li> <li>Configuring the retention period for GitHub Actions artifacts and logs in your organization</li> <li>Enforcing a policy for artifact and log retention in your enterprise</li> </ul> </li> <li> <p>In addition to configured setings across a repository, organization or enterpise, it is possible to define a custom retention period for individual artifacts within the workflow file. </p> </li> <li> <p>Example of individual workflow use case using <code>retention-days</code> along with <code>upload-artifact</code> attributes:</p> <pre><code>- name: 'Upload Artifact'\n  uses: actions/upload-artifact@v2\n  with:\n    name: my-artifact\n    path: my_file.txt\n    retention-days: 10\n</code></pre> </li> </ul> </li> </ol> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/4.%20Remove%20artifacts%2C%20create%20status%20badges%2C%20and%20configure%20environment%20protections/#adding-a-worflow-status-badge-to-repository","title":"Adding a worflow status badge to repository","text":"<p>It's helpful to know the status of a workflow without having to visit the Actions tab to see if it successfully completed. With GitHub it can be achieved by placing the status badges of the workflow to repositories <code>README.md</code> file. By default, status badges display the workflow statuses on default branch, however it is customizable to display workflow status badges on other branches using the <code>branch</code> and event <code>parameters</code>. Adding the <code>branch</code> parameter along with the desired branch name at the end of URL will show the workflow status for that branch. It is also possible to create badge using GitHub by navigating to Actions tab and selecting a specific workflow. The <code>Create status badge</code> option will allow to generate the markdown for that workflow and set the <code>branch</code> and <code>event</code> parameters.  </p> <p>An example of what needs to be added to see a worfklos status badge: <pre><code>![example branch parameter.](https://github.com/mona/special-octo-eureka/actions/workflows/grading.yml/badge.svg?branch=my-workflow)\n</code></pre></p>"},{"location":"GitHub%20Actions%20Accreditation/4.%20Continuos%20Delivery/4.%20Remove%20artifacts%2C%20create%20status%20badges%2C%20and%20configure%20environment%20protections/#add-workflow-environment-protections","title":"Add workflow environment protections","text":"<p>It make sense to configure workflow envirnment with protection rules and secrets. With the protection a job won't start or access any defined secrets in the environment untill all of the environment's protection rules pass. For now protection rules and environment secrets only apply to public repositories.</p> <p>There are two environment protection rules that are possible to apply to workflows within <code>public repositories</code>, <code>required reviewers</code> and <code>wait timer</code>:</p> <ul> <li>Required reviewers allows to set a specific person or team to approve workflow jobs that reference the job's environment.</li> <li> <p>Wait timer can be used to <code>delay</code> a job for a specific amount of time after the job has been <code>triggered</code>.</p> <ul> <li> <p>For example if it's necessary to create a workflow to a production environment that a <code>dev</code> team needs to approve before the deployement occurs, the steps would look be:</p> <ol> <li>Create a <code>production environment</code> within the repository</li> <li>Configure the required reviewers environment protection to require an approval from the specific <code>dev</code> team</li> <li>Configure the specific job within the workflow for the <code>production</code> environment</li> </ol> </li> <li> <p>The repository can be created and configured from the repository's <code>Settings</code> tab under <code>Environments</code>.</p> </li> </ul> </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/1.%20Actions%20and%20Workflows/","title":"Action and Workflows","text":""},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/1.%20Actions%20and%20Workflows/#enterpise-level","title":"Enterpise Level","text":"<ul> <li>It is possible to configure a <code>GitHub Actions use policy</code> at this level. The admin can set policies so that there is a limited possibility to use possibly malicious third party actions. This can be configired out of the box using both GitHub Enterprise Cloud &amp; Server. In order to configure a <code>GitHub Actions use policy</code> for enterprise, navigate to enterprise account and then to Policies &gt; Actions in the sidebar. The options presented below should appear:</li> </ul> <p>The option are:</p> <ol> <li>Allow all actions</li> <li>Allow only local actions (in the enterprise repositories)</li> <li>Set a more specific criteria for the actions</li> <li>Disallow Actions altogether</li> </ol> <p>For option 3 there are more available customizations: </p> <ul> <li>It can be narrowed down to ONLY actions created by GitHub, by verified creators, or by list of actions are allowed to use.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/1.%20Actions%20and%20Workflows/#manually-sync-public-actions-for-enterprise-server","title":"Manually sync public actions for Enterprise Server","text":"<p>Most official GitHub-authored actions come automatically bundled with Enterprise Server, and are captured at a point in time from the GitHub Marketplace. They include <code>actions/checkout</code>, <code>actions/upload-artifact</code>, <code>actions/download-artifact</code>, <code>actions/labeler</code> and various actions/setup- actions, among others. To see all the official actions included on enterprise instance, browse to the actions organization on instance: https://HOSTNAME/actions.</p> <p>It's also possible to connect the Enterprise Server to the GitHub marketplace to get new ones. However, if it must to retain control over that actions on instance, it is preferable to use the actions-sync tool to manually download actions and enable them in enterprise instance.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/1.%20Actions%20and%20Workflows/#organization-level","title":"Organization Level","text":"<p>Creating a GitHub Actions workflow often involves writing multiple files and creating several repositories to specify the workflow in itself, as well as the actions, containers and/or runners to use in the workflow. Depending on the number of users in Enterprise Cloud or Enterprise Server instance, things can get messy, if there is no corporate standards in place for creating GitHub Actions workflows.</p> <p>GitHub recommends to have certain criteria for mananaging how organization does its actions. There should be a repository for this with a GitHub wiki or a markdown file. It should be available for everyone within an organization. Repository should contain:</p> <ul> <li>Repositories for storage</li> <li>Files/folders naming conventions established</li> <li>Location of shared components</li> <li>Plans for ongoing maintenance</li> <li>Contribution guidlines</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/1.%20Actions%20and%20Workflows/#create-workflow-templates","title":"Create workflow templates","text":"<ul> <li> <p>Both in Enterprise Cloud and Server, users with write access to an organization's <code>.github</code> repository can create workflow templates that will be available for use to the other organization's members with the same write access. </p> </li> <li> <p>Workflow templates can then be used to create new workflows in the <code>public</code> and <code>private</code> repositories of the organization. This ensures consistency in the practices and, by proxy, in quality.</p> </li> </ul> <p>To create a template:</p> <ol> <li>Create a <code>.yml</code> workflow file</li> <li>Create a <code>.json</code> metadata file that describes how the template is presented to users when they are creating a workflow. <code>NOTE</code>:  The metadata file must have the same name as the workflow file. Instead of the <code>.yml</code> extension, it must be appended with <code>.properties.json</code>. For example, a file named <code>octo-organization-ci.properties.json</code> contains the metadata for the workflow file named <code>octo-organization-ci.yml</code>.</li> <li>Place files in a public <code>.github</code> repository and in a directory <code>workflow-templates</code>.</li> </ol> <p>This is what it might look like:</p> <pre><code>name: Octo Organization CI\n\non:\n  push:\n    branches: [ $default-branch ]\n  pull_request:\n    branches: [ $default-branch ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Run a one-line script\n        run: echo Hello from Octo Organization\n</code></pre> <p>Note that the above file uses a <code>$default-branch</code> placeholder. When a workflow is created using template, this placeholder is automatically replaced with the name of the repository's default branch.</p> <p>Below is the metadata file that workflow file requires: <pre><code>{\n\"name\": \"Octo Organization Workflow\",\n\"description\": \"Octo Organization CI workflow template.\",\n\"iconName\": \"example-icon\",\n\"categories\": [\n\"Go\"\n],\n\"filePatterns\": [\n\"package.json$\",\n\"^Dockerfile\",\n\".*\\\\.md$\"\n]\n}\n</code></pre> Metadata files use the following parameters:</p> Parameter Description Required name Name of the workflow template displayed in the list of available templates Yes description Description of the workflow template displayed in the list of available templates Yes iconName Defines an icon for the workflow's entry in the template list. Must be an SVG icon of the same name, and must be stored in the workflow-templates directory. For example, an SVG file named example-icon.svg is referenced as example-icon. Yes categories Defines the language category of the workflow. When a user views the available templates, the templates that match the same language will feature more prominently. No filePatterns Enables the template to be used if the user's repository has a file in its root directory that matches a defined regular expression. No <ul> <li>The keys <code>name</code>, <code>description</code> and <code>iconName</code> are required and quite self-explaining.</li> <li><code>Categories</code> (optional) defines the language category of the workflow. </li> <li><code>filePatterns</code> (optional) enables the template to be used if the user's repository has a file in it's root directory that matches the defined regular expression.</li> </ul> <p>Once a workflow template is created, users in organization can find it under <code>Actions</code> &gt; <code>New workflow</code> &gt; <code>Workflows created by &lt;organization_name&gt;</code>. </p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/","title":"Manage Runners","text":"<p>GitHub Actions workflows can be executed by two types of runners: GitHub-hosted runners or selfhosted runners. GitHub-hosted runners are not supported on GitHub Enterprise Server.</p> <p>Reasons to use self-hosted runners:</p> <ul> <li>IP allowlist is restricted</li> <li>Using specialized hardware for the runners</li> <li>Having a very specific environment</li> </ul> GitHub-hosted runners Self-hosted runners Receive automatic updates for the operating system, preinstalled packages and tools, and the self-hosted runner application. Receive automatic updates for the self-hosted runner application only. You are responsible for updating the operating system and all other software. You can use cloud services or local machines that you already pay for. Are managed and maintained by GitHub. Can be customized to your hardware, operating system, software, and security requirements. Provide a clean instance for every job execution. Don't need to have a clean instance for every job execution. Use free minutes on your GitHub plan, with per-minute rates applied after surpassing the free minutes. Are free to use with GitHub Actions, but you are responsible for the cost of maintaining your runner machines. <p>Interesting: self-hosted does not need to have a clean instance.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#configuring-access-to-self-hosted-runners","title":"Configuring access to self-hosted runners","text":"<ul> <li> <p>In Enterprise Cloud and Enterprise Server, self-hosted runner groups enables to control access to <code>self-hosted</code> runners at the organization and enterprise level. This feature can come in handy for cases where it requires to restrict access to <code>self-hosted</code> runners to specific organizations or users, for example based on the level of trust for these organizations or users, or to mitigate security risks.</p> </li> <li> <p>Let's say you want to authorize only specific organizations in your enterprise instance to deploy code to your production environment. In order to achieve this, you could create a group containing all the runners deploying code into production at enterprise level and restrict the access to the group to the specific organizations authorized to deploy code.</p> </li> <li> <p>To create groups at enterprise level, navigate to your enterprise account and then to <code>Policies</code> &gt; <code>Actions</code> in the sidebar. In the <code>self-hosted runners</code> tab, select <code>Add new</code> &gt; <code>New group</code>. The screen that appears will enable you to specify a group name and an access policy for organizations.</p> </li> </ul> <p></p> <p>To create groups at organization level, navigate to your organization Settings and then to Actions in the sidebar. In the Self-hosted runners section, select Add new &gt; New group. The screen that appears enables you to specify a group name and an access policy for repositories.</p> <p></p> <p>So essentially you can define on the enterprise level which organizations can use which groups of runners and on organization level you can do the same, but you define the groups for repositories.</p> <p>NOTE:</p> <ol> <li>When a runner is created it is assigned to the default group.</li> <li>A runner can be in only ONE group at a time.</li> <li>Runners can be moved from a group to another one</li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#configure-self-hosted-runners-for-enterprise-use","title":"Configure Self-Hosted Runners for Enterprise Use","text":"<p>Enterprise Cloud and Enterprise Server offer multiple features enabling to customize self-hosted runners for enterprise usage. Some of these features include <code>labels</code>, <code>proxy servers</code>, and <code>IP allowlists</code>.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#labels","title":"Labels","text":"<p>Self-hoster runners automatically receive default labels when they are added to GitHub Actions. These labels are used to identify the operating system and architecture of the runner. For example, a runner running on a Linux machine with an x64 architecture will receive the following labels:</p> <ul> <li><code>self-hosted</code> &gt; Default label for all self-hosted runners</li> <li><code>linux</code>, <code>windows</code>, <code>macOS</code> &gt; Applied depending on the OS</li> <li><code>x64</code>, <code>ARM</code>, <code>ARM64</code> &gt; Applied depending on the hardware architecture</li> </ul> <p>On top of these default labels, Enterprise Cloud and Enterprise Server offers the possibility to create and add custom labels to runners. Custom labels can come in handy for cases when it is required to identify a specific capabilities of a runner. For example if a job in worfklow requires a specific type of graphics hardware, the custom gpu label can be created and assigned to the runner that have the required hardware. <code>All runners with the gpu label would then be eligible to run the job</code>. </p> <p>So it is possible to define which runner is meant for which job. </p> <p>In order to add a label to a self-hosted runner: navigate to the GitHub Actions setting of the organization, repository, or enterprise where self-hosted runner is registered (under Actions for an orgaization on repository, under Policies &gt; Actions for an enterprise). </p> <ol> <li> <p>Locate the list of runners under <code>Self-hosted</code> runners. If runner is in a group, locate to runner group and select the runner dropdown to view the list of runners.</p> </li> <li> <p>Locate the runner to update and select the label dropdown to view the label selection menu. This menu displays all the custom labels available to your self-hosted runner. Labels already assigned to your self-hosted runner have a tick next to them.</p> </li> <li> <p>Click an existing label to add it to your runner or type the name of your new label in the Filter labels field and select Create new label. The label is automatically added to your runner when you create it.</p> </li> </ol>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#proxy-servers","title":"Proxy Servers","text":"<p>If you need a self-hosted runner to communicate with GitHub via a proxy server, both Enterprise Cloud and Enterprise Server enable you to change proxy configurations using the following environment variables:</p> Environment variable Description https_proxy Proxy URL for HTTPS traffic, including basic authentication credentials if necessary. For example: <code>https://proxy.local</code> <code>https://192.168.1.1:8080</code> <code>https://username:password@proxy.local</code>. http_proxy Proxy URL for HTTP traffic, including basic authentication credentials if necessary. For example: <code>http://proxy.local</code> <code>http://192.168.1.1:8080</code> <code>http://username:password@proxy.local</code>. no_proxy Comma-separated list of hosts that should not use a proxy. Only hostnames are allowed in no_proxy, you cannot use IP addresses. For example: <code>example.com</code> <code>example.com,myserver.local:443,example.org</code>. <p>Proxy environmnet variables are read when the self-hosted runner application starts, so engineer must set the environment variables before configuring or starting the application. If proxy configuration changes, it requires to restart the self-hosted runner application.</p> <p>In Windows environment the proxy variable names are not case sensitive. On Linux and MacOS the recommended way is to specify all of the environment variable names in a lowercase. If there are environment variables in both uppercase and lowercase on Linux or macOS, gor example https_proxt and HTTPS_PROXY, the self-hosted runner application will use the lowercase variable.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#ip-allowlists","title":"IP Allowlists","text":"<p>If IP allowlist is configured, there should be included the IP address or IP address range of self-hosted runners in order to have a communiction between the self-hosted runner and GitHub. To add the IP address or IP address range of self-hosted runners to an organization IP allowlist, navigate to organizations Settings and select Organization security in the sidebar. Under IP Address, add the IP address or IP address range of self-hosted runners in CIDR notation and select + Add.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/2.%20Runners/#monitor-and-troubleshoot-self-hosted-runners","title":"Monitor and troubleshoot self-hosted runners","text":"<p>Both Enterprise Cloud and Enterprise Server offer tools enabling to monitor, troubleshoot and update self-hosted runners. If builds start to fail, some files in repository get locker, or workflow runs are stuck, troubleshooting the runner executing the workflow can help solve the issue. The main steps to troubleshoot a self-hosted runner are:</p> <ol> <li>Ceck the status of the runner in the GitHub Actions settings of the organization, repository, or enterprise where self-hosted runner is registered: <ul> <li>Under <code>Actions</code> for an organization or repository </li> <li>Ynder <code>Policies &gt; Actions</code> for an enterprise</li> </ul> </li> <li>Review the activities and automatic updates of the runner in the Runner_files in the _diag folder.</li> <li>Review the status of the jobs of the jobs the runner executed in the Worker_ files in the _diag folder.</li> </ol> <p>According to the operation system of the runner, the extra steps can be taken as shown in the following table:</p> Mac Windows Linux Check the self-hosted runner application service using <code>launchd</code> Check the self-hosted runner application service using <code>PowerShell</code> - Check the self-hosted runner application service using <code>journalctl</code> - If jobs require containers, check that Docker is installed and running and the Docker permissions using <code>systemctl</code>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/","title":"Manage encrypted secrets","text":"<p>Secrets are encrypted environment variables that can be created to store tokens, credentials, or any other type of sensitive information in GitHub Action workflows that action might rely on. Once created, they become available to use in the workflows and actions that have access to the organization, repository or repository environment where they are stored.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/#secrets-at-organization-level","title":"Secrets at Organization Level","text":"<p>To create a secret at organization level, go to organization Settings and select Secrets &gt; New organization secret in the left sidebar. In the screen that appears, enter a name and a value and choose repository access policy for the secret: </p> <p>The access policy appears inderneath the secret in the secret list once it is saved. The <code>Update</code> button allows to cgange the details on the configured permissions that secret have. </p> <p>Setting a secret at this level is an excellent idea if that secret should be available to all around the organization. Insead of having it in every single repository, it is now accessable from a single place on the organization level.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/#secrets-at-repository-level","title":"Secrets at Repository Level","text":"<p>To create a secret at repository level, go to repository <code>Settings</code> and select <code>Secrets</code> &gt; <code>New repository secret</code> in the left sidebar. In the screen that appears, enter a name and a value for new secret. It looks exactly similar to organization level, but the secret is <code>ONLY</code> for the repository and doesn't have \"repository access\" policy permissions.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/#accessing-encrtyped-secrets-within-actions-and-workflows","title":"Accessing encrtyped secrets within Actions and Workflows","text":""},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/#in-workflows","title":"In workflows","text":"<p>In order to access an <code>encrypted secret</code> in a <code>workflow</code> users must use <code>secrets</code> context in a workflow file: <pre><code>steps:\n  - name: Hello world action\n    with: # Set the secret as an input\n      super_secret: ${{ secrets.SuperSecret }}\n    env: # Or as an environment variable\n      super_secret: ${{ secrets.SuperSecret }}\n</code></pre></p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/3.%20Encrypted%20Secrets/#in-actions","title":"In actions","text":"<p>In order to access an <code>encrypted secret</code> in an <code>action</code> users must specify secret as an <code>input</code> parameter in the <code>action.yml</code> metadata file:</p> <p><pre><code>inputs:\n  super_secret:\n    description: 'A super secret'\n    required: true\n</code></pre> E.g. that means that when secret is created, an action can only get the secrets as input. In this case the action code could read the value of the input using the <code>INPUT_SUPER_SECRET</code> environment variable.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/","title":"Usage limits","text":"<p>There are usage limits for GitHub Actions workflows. Usage charges apply to repositories that go beyond the amount of free minutes and storage for repository. GitHub Actions usage is free for standard <code>GitHub-hosted</code> runners in <code>public</code> repositories, and for <code>self-hosted</code> runners. For <code>private</code> repositories, each GitHub account receives a certain amount of free minutes and storage for use with <code>GitHub-hosted</code> runners, depending on the product used with the account. Any usage beyond the included amounts is controlled by spending limits.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#limits","title":"Limits","text":"<ul> <li>GitHub Actions is available on all GitHub products, but GitHub Actions is not available for private repositories owned by accounts using legacy per-repository plans.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#limits-for-github-actions-usage","title":"Limits for GitHub Actions usage","text":"<ul> <li><code>Job execution time</code> is limited to 6 hours of execution time. If job reaches the limit, the job will be terminated and fail to complete.</li> <li><code>Worfklow run time</code> is limitied to 35 days. If a worfklow run reaches the limit, the workflow run will be cancelled. This period includes exection duration, and time spent on waiting and approval.</li> <li><code>API requests</code> are limited to 1,000 requests to the GitHub API in an hour across all actions within a repository. If requests are exceeded, additional API calls will fail which might cause jobs to fail.</li> <li><code>Concurrent jobs</code> limitation depends on the GitHub plan as well as the type of runner used. If exceeded, any additional jobs are queued. </li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#standard-github-hosted-runners","title":"Standard GitHub-hosted runners","text":"GitHub plan Total concurrent jobs Maximum concurrent MocOs jobs Free 20 5 Pro 40 5 Team 60 5 Enterprise 180 50"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#lage-githus-hosted-runners","title":"Lage GitHus-hosted runners","text":"GitHub plan Total concurrent jobs Maximum concurrent MocOs jobs All 500 n/a <ul> <li><code>Job matrix</code> can generate a maximus of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.</li> <li><code>Workflow run queue</code> is limited to 500 workflow runs in a 10 second interval per repository. If a workflow run reaches the limit, the workflow run will be terminated and fail to complete.</li> </ul>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#billing-for-reusable-workflows","title":"Billing for reusable workflows","text":"<p>In case of a workflow reusing, billing is always associated with the caller workflow. Assignment of GitHub-hosted runners is always evaluated using only the caller's context. The caller cannot use GitHub-hosted runners from the called repository.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#artifact-and-log-retention-policy","title":"Artifact and log retention policy","text":"<ul> <li>Artifact and log retention period can ba configured in the repoistory, organization or enterprise accounts. </li> <li>By default the artifacts and log files generated by workflows are retained for 90 days before they are automatically deleted. Depending on the type of repository, retention period can be changed:<ul> <li>for <code>public</code> it can be anywhere between 1 to 90 days.</li> <li>for <code>private</code> it can be anywhere between 1 to 400 days.</li> </ul> </li> </ul> <p>New customization only applies to new artifacts and log files, and does not retroactively apply to existing objects. For managed repositories and organizations the maximum retention period cannot exceed the limit set by managing organization or enterprise.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#disabling-or-limiting-github-actions","title":"Disabling or limiting GitHub Actions","text":"<p>By default, GitHub Actions are enabled on all repositories and organizations. GitHub Actions configuration can be disabled or limited to actions and reusable workflows in an organization.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#disabling-and-enabling-workflows","title":"Disabling and enabling workflows","text":"<p>GitHub allows to disable or enable individual workflows in repository on GitHub. To prevent unnecessary workflow runs, scheduled workflows can be disabled automatically. In a public repository, scheduled workflows are automatically disabled when no repository activity has occured in 60 days.</p>"},{"location":"GitHub%20Actions%20Accreditation/5.%20GitHub%20Enterprise%20and%20Usage%20Limits/4.%20GitHub%20Usage%20Limits/#limits-for-configuration-variables","title":"Limits for configuration variables","text":"<p>You can store up to 1,000 organization variables, 100 repository variables, and 100 environment variables.</p> <p>A workflow created in a repository can access the following number of variables:</p> <p>All 100 repository variables. If the repository is assigned access to more than 100 organization variables, the workflow can only use the first 100 organization variables (sorted alphabetically by variable name). All 100 environment variables. Variables are limited to 48 KB in size.</p>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/","title":"Introduction to GitHub administration","text":""},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#github-administration-at-team-level","title":"GitHub Administration at team level","text":"<p>GitHub enables users to form teams within organizations, granting more precise repository permissions and fostering communication.</p> <p>Teams aid in refining permissions and communication among members. Synchronization with identity provider (IdP) groups like Azure AD automates updates, reducing manual tasks. Azure AD facilitates onboarding, permissions, and access management.</p> <p>Team maintainers/admins can:</p> <ul> <li>Create, rename, delete teams.</li> <li>Manage members, sync with IdP groups.</li> <li>Add outside collaborators.</li> <li>Enable/disable discussions.</li> <li>Adjust team visibility.</li> <li>Handle code review assignment.</li> <li>Set reminders and profile picture.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#best-practices-for-team-level-administration","title":"Best practices for team-level administration","text":"<p>Creating teams within organization on GitHub offers collaboration flexibility and simplifies repository and permission management. Best practices for team setup include:</p> <ol> <li> <p>Nested Teams: Reflect organization's hierarchy with nested teams within GitHub organization.</p> </li> <li> <p>Interest-Based Teams: Create teams based on interests or specific technologies (e.g., JavaScript, data science) to streamline PR reviews. Members can join based on their skills and interests.</p> </li> <li> <p>Team Synchronization: Enable synchronization between identity provider (IdP) and GitHub. This lets owners and maintainers link GitHub teams with IdP groups. Synchronization automates updates, reducing manual work. IdP synchronization helps manage tasks like onboarding, permissions, and access removal.</p> </li> </ol>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#administation-at-organization-level","title":"Administation at organization level","text":"<p>GitHub organizations provide collaborative spaces for users to work on multiple projects concurrently. Owners and administrators wield robust security and administrative tools to manage member access and repository data.</p> <p>Owners in an organization enjoy comprehensive privileges, including:</p> <ul> <li>Inviting and removing users from the organization.</li> <li>Creating and supervising teams, designating \"team maintainers\" among members.</li> <li>Adding external collaborators to repos.</li> <li>Assigning repository permissions and default levels.</li> <li>Establishing organization security.</li> <li>Managing billing and assigning billing managers.</li> <li>Gathering repository data with custom scripts.</li> <li>Implementing organization-wide changes through custom scripts.</li> </ul> <p>It's advisable to have just one organization; creating multiple organizations poses challenges:</p> <ul> <li>Duplication and configuration sharing aren't possible, leading to repeated setup and potential errors.</li> <li>Additional costs might arise for applications installed across multiple organizations.</li> <li>Managing multiple organizations is generally more complex.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#administration-at-enterprise-level","title":"Administration at enterprise level","text":"<p>Enterprise accounts encompass GitHub Enterprise Cloud and Enterprise Server instances, providing centralized policy and billing management for multiple organizations.</p> <p>At the enterprise level, owners with appropriate permissions can:</p> <ul> <li>Implement SAML single sign-on for the enterprise, linking external identities via an identity provider (IdP) to GitHub accounts.</li> <li>Manage enterprise organizations by adding or removing them.</li> <li>Set up billing or assign a billing manager for all organizations in the enterprise.</li> <li>Set up policies for repository management, project boards, teams, and security settings that apply across the enterprise's organizations, repositories, and members.</li> <li>Gather organization data using custom scripts.</li> <li>Implement enterprise-wide changes, such as migrations, using custom scripts.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#github-authentication-options","title":"GitHub authentication options","text":"<p>GitHub offers various authentication methods and security features:</p> <ol> <li> <p>Authentication Options:</p> <ul> <li>Username and password (basic authentication) can be used, but other options are recommended for enhanced security.</li> <li>Personal access tokens (PATs) serve as password alternatives for API and command-line interactions.</li> <li>SSH keys enable remote server authentication, eliminating the need for tokens or passwords.</li> </ul> </li> <li> <p>SSH Keys:</p> <ul> <li>Users can generate SSH keys to authenticate to remote servers and services without tokens or passwords.</li> <li>the SSH key should be added the ssh-agent and GitHub account.</li> <li>Keys can also be used with SAML single sign-on (SSO) and SSH certificates.</li> </ul> </li> <li> <p>Deploy Keys:</p> <ul> <li>SSH keys specific to a single repository for read or write access.</li> <li>Deploy keys are read-only by default, but they can get write access when adding them to a repository</li> </ul> </li> <li> <p>Security Options:</p> <ul> <li>Two-factor authentication (2FA) adds an extra layer of security via a generated code. Organization owners can require organization members, outside collaborators, and billing managers to enable two-factor authentication for their personal accounts, making it harder for malicious actors to access an organization's repositories and settings. Enterprise owners can also enforce certain security policies for all organizations owned by an enterprise account.</li> <li>SAML SSO offers centralized identity management and access control. GitHub offers limited support for all identity providers that implement the SAML 2.0 standard with official support for several popular identity providers including:<ul> <li>Active Directory Federation Services (AD FS)</li> <li>Azure Active Directory (Azure AD)</li> <li>Okta</li> <li>OneLogin</li> <li>PingOne</li> </ul> </li> <li>LDAP integrates GitHub Enterprise Server with existing user directories. GitHub Enterprise Server integrates with popular LDAP services like:<ul> <li>Active Directory</li> <li>Oracle Directory Server Enterprise Edition</li> <li>OpenLDAP</li> <li>Open Directory</li> </ul> </li> </ul> </li> </ol>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#repository-permission-levels","title":"Repository permission levels","text":"<p>Customize repository access by assigning five levels of permissions:</p> <ul> <li>Read: For viewing and discussing projects, recommended for non-code contributors.</li> <li>Triage: Allows issue and pull request management, suitable for non-writers like project managers.</li> <li>Write: Standard permission for active contributors who push to the project.</li> <li>Maintain: Enables repository management without destructive actions, suitable for project managers.</li> <li>Admin: Full access, including sensitive actions like security management, for repository owners and administrators.</li> </ul> <p>Assign different access levels to members, collaborators, and teams within your organization. Select the appropriate level based on roles, ensuring no unnecessary access.</p>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#team-permission-levels","title":"Team permission levels","text":"<p>Teams simplify assigning repository permissions to multiple users. Child teams inherit parent team permissions, facilitating cascading permissions based on company structure.</p> <p>Team Level Permissions:</p> Permission Level Description Member Same abilities as org members Maintainer All member abilities, plus: Change team details Manage parent/child teams Set team profile picture Edit/delete team discussions Add/remove org members Promote members to maintainers Remove team's repo access Manage code review assignment Manage PR scheduled reminders <p>Organization owners can promote org members to team maintainers.</p>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#organization-permission-levels","title":"Organization permission levels","text":"<p>There are three levels of permissions at the organizational level:</p> Permission Level Description Owner All org member abilities, manage users Member Create/manage org repos and teams Billing manager View/edit billing info <p>You can set default permissions for all org members:</p> <ul> <li>None: Clone/pull public repos. Add to teams for more access.</li> <li>Read: Clone/pull all repos.</li> <li>Write: Clone/pull/push all repos.</li> <li>Admin: Full access, add new collaborators.</li> </ul> <p>For better management, consider default read access and adjust permissions case-by-case. For small orgs or trusted members, granting more access upfront may be suitable.</p>"},{"location":"GitHub%20Administration%20Certification/1.%20Introduction%20to%20GitHub%20Administration/#enterprise-permission-levels","title":"Enterprise permission levels","text":"<p>There are three levels of permission at the enterprise level:</p> Permission Level Description Owner Full control, manage admins/orgs/settings Member Same abilities as org members Billing manager View/edit billing, add/remove managers <p>You can set default repo permissions across your orgs:</p> <ul> <li>No policy: Orgs set defaults.</li> <li>Admin: Clone/pull/push/add collaborators.</li> <li>Write: Clone/push/push all org repos.</li> <li>Read: Clone/pull all org repos.</li> <li>None: Clone/pull public repos.</li> </ul> <p>For better management, consider default read access and adjust permissions case-by-case. In a small enterprise, you might trust all with write access.</p>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/","title":"Introduction to GitHub's products","text":""},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-products-and-accounts-overview","title":"GitHub Products and Accounts Overview","text":"<p>GitHub offers various products for software management and collaboration:</p>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#products","title":"Products:","text":"<ul> <li> <p>GitHub Free: Basics for individuals and organizations, including unlimited public and private repositories.</p> </li> <li> <p>GitHub Pro: Advanced features for individual developers, including GitHub Support via Email and enhanced limits.</p> </li> <li> <p>GitHub Team: Similar to Pro but for organizational use, promoting collaboration.</p> </li> <li> <p>GitHub Enterprise: Hosted on-premises or in the cloud, with extra support, security, and controls.</p> </li> <li> <p>GitHub Enterprise Cloud: Cloud version of Enterprise with increased limits.</p> </li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#accounts","title":"Accounts:","text":"<ul> <li> <p>Personal user accounts: For individuals.</p> </li> <li> <p>Organization accounts: For organizations.</p> </li> <li> <p>Enterprise accounts: For larger entities.</p> </li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-free","title":"GitHub Free:","text":"<ul> <li>Unlimited public/private repositories.</li> <li>Actions automation and Packages storage limits.</li> <li>Additional features for organizations.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-pro","title":"GitHub Pro:","text":"<ul> <li>Includes Pro features plus enhanced tools.</li> <li>Increased limits for private repositories.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-team","title":"GitHub Team:","text":"<ul> <li>Same as Pro, tailored for organizations.</li> <li>Collaboration-enhancing features.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-enterprise","title":"GitHub Enterprise:","text":"<ul> <li>On-premises or cloud hosting.</li> <li>Greater support, security, and controls.</li> <li>Single sign-on and access provisioning.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-enterprise-cloud","title":"GitHub Enterprise Cloud:","text":"<ul> <li>Cloud version of Enterprise with more resources.</li> </ul> <p>For detailed information, refer to GitHub's documentation.</p>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#github-features-licensing-and-pricing","title":"GitHub Features Licensing and Pricing","text":"<p>GitHub offers different features with varying licensing and pricing structures. Some features are available depending on the product type, while others are \"rate-based,\" requiring payment for additional usage.</p>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#licensing-for-metered-products","title":"Licensing for Metered Products","text":"<ul> <li>GitHub Actions is free for public repositories and self-hosted runners.</li> <li>For private repositories, each GitHub account has a certain number of free minutes, based on the product used.</li> <li>A spending limit of $0 prevents additional usage beyond your limit.</li> <li>Overages are billed if the spending limit is increased.</li> <li>Windows and macOS runners consume minutes at different rates than Linux runners.</li> </ul> Operating System Minute Multiplier Linux 1 macOS 10 Windows 2 <ul> <li>Free minutes reset monthly.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#licensing-github-packages","title":"Licensing GitHub Packages","text":"<ul> <li>Storage for GitHub Packages works similarly, but storage capacity doesn't reset monthly.</li> <li>Storage usage is calculated based on hourly usage during the month.</li> <li>Storage usage is rounded to the nearest megabyte at the end of the month.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#spending-limits","title":"Spending Limits","text":"<ul> <li>Accounts have a default spending limit of $0 for GitHub Actions usage.</li> <li>Increasing the spending limit or allowing unlimited spending is possible.</li> <li>Accounts with unpaid charges affect storage or minutes included.</li> <li>Enterprise accounts billed by invoice have unlimited default spending limits.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#codespaces-billing","title":"Codespaces Billing","text":"<ul> <li>GitHub Codespaces usage is billed monthly.</li> <li>Organization and enterprise accounts are billed.</li> <li>Personal accounts have free usage up to a fixed amount.</li> <li>Compute costs are incurred while codespaces are active.</li> <li>Storage billing continues until quota is used up or spending limit reached.</li> <li>Storage billing for codespaces ends when they're deleted.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#viewing-usage","title":"Viewing Usage","text":"<ul> <li>GitHub UI provides statistics of license usage for specific organizations, accounts, and instances.</li> <li>Context switching allows organization/enterprise owners to switch between accounts easily.</li> <li>Context switching demonstrates GitHub's capability to enable usage management across accounts.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#manage-licenses-across-organizations","title":"Manage Licenses Across Organizations","text":"<ul> <li>Organization owners can monitor and manage licensed seats by navigating to Billing and plans from their profile photo.</li> <li>For owners managing multiple organizations, they can select the specific organization they want to view.</li> <li>They can then view their current plan and add or remove seats.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#manage-licenses-across-enterprises-and-instances","title":"Manage Licenses Across Enterprises and Instances","text":"<ul> <li>Enterprise owners overseeing multiple enterprises or instances can manage licenses by selecting <code>Your Enterprises</code> from the <code>Settings</code> dropdown menu in their profile.</li> <li>GitHub Enterprise Server licenses can be viewed and managed at the server instance level.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#monitoring-metered-product-consumption","title":"Monitoring Metered Product Consumption","text":"<ul> <li>Metered products like GitHub Actions and GitHub Packages are billed based on consumed minutes or gigabytes beyond the allotted amount.</li> <li>The GitHub interface provides consumption statistics.</li> <li>Billing &amp; plans section shows current plans, GitHub Actions minute usage, and GitHub Packages storage usage.</li> <li>CSV reports can also be sent to your email address for monitoring.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#setting-spending-limits","title":"Setting Spending Limits","text":"<ul> <li>Control spending for actions and packages usage by setting spending limits.</li> <li>Adjust limits according to operational growth for budgeting purposes.</li> <li>Spending limits offer safety and control in case of configuration errors causing unexpected billing.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/2.%20Introduction%20to%20GitHub%20products/#monitoring-git-lfs-data","title":"Monitoring Git LFS Data","text":"<ul> <li>Manage Git LFS (Large File Storage) Data through the GitHub UI.</li> <li>View storage and bandwidth usage.</li> <li>Git Large File Storage users receive 1 GB of free storage and 1 GB/month of free bandwidth.</li> <li>Additional storage and bandwidth can be purchased if needed.</li> <li>Payment is based on asset pushes and downloads.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/","title":"Maintain a secure repository by using GitHub best practices","text":""},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#how-to-maintain-a-secure-github-repository","title":"How to maintain a secure GitHub repository","text":"<p>In today's landscape, the security of applications is paramount. News often highlights breaches where systems are compromised, resulting in the theft of private data from companies and customers.</p> <p>To establish a solid secure development strategy, several aspects must be considered. Protecting sensitive information from unauthorized access is crucial. Equally important is safeguarding data from inappropriate changes or destruction and ensuring proper disposal.</p> <p>Validating user identity and permissions is essential. Historical data and logs are vital for tracing issues when they arise.</p> <p>Key Considerations for Secure Application Development:</p> <ol> <li> <p>Constant Learning: Security is an evolving domain. Ongoing education and training are necessary, as many assume understanding without staying updated.</p> </li> <li> <p>Proper Coding: Code creation must prioritize both correctness and security. Security-centric design of features is vital.</p> </li> <li> <p>Regulatory Adherence: Compliance with rules and regulations is imperative. Continuous testing for compliance during development and post-deployment is vital.</p> </li> </ol> <p>Security integration can't be an afterthought. It must be integrated throughout the software life cycle, especially for critical and sensitive applications.</p> <p>Shifting security left in the development process is crucial. Developers need security feedback early to prevent errors and expedite development.</p> <p>A Shift Left Approach:</p> <ul> <li> <p>GitHub Security Policy: A SECURITY.md file in repositories helps responsible disclosure of security concerns, speeding up resolutions.</p> </li> <li> <p>GitHub Security Advisories: Privately addressing and disclosing vulnerabilities assists the community in staying updated.</p> </li> <li> <p>.gitignore: Ignoring sensitive files using .gitignore minimizes risks of inadvertent exposure.</p> </li> <li> <p>Sensitive Data Removal: Developers must be vigilant about removing sensitive data from repositories.</p> </li> <li> <p>Branch Protection Rules: Enforcing workflows, reviews, and tests for protected branches enhances code quality.</p> </li> <li> <p>CODEOWNERS File: Assigning code ownership to team members or groups for specific files ensures thorough reviews.</p> </li> </ul> <p>Incorporating security from the outset reduces rework and accelerates software development. It's about embedding security throughout the process, making security a shared responsibility across teams.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#detecting-and-fixing-outdated-dependencies-with-security-vulnerabilities","title":"Detecting and Fixing Outdated Dependencies with Security Vulnerabilities","text":"<p>External package dependencies are commonplace. While they boost productivity, they can also introduce security risks. Managing these dependencies and their vulnerabilities can be time-consuming, especially considering their nested dependencies. GitHub offers tools to alleviate this burden.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#repository-dependency-graphs","title":"Repository Dependency Graphs","text":"<p>Every repository benefits from dependency graphs. GitHub scans common package manifests like <code>package.json</code> and <code>requirements.txt</code>, allowing project owners to track dependencies recursively.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#automated-dependency-alerts","title":"Automated Dependency Alerts","text":"<p>GitHub's automated alerts monitor dependency graphs, cross-referencing target versions with known vulnerabilities. When risks are identified, the project is alerted using GitHub Security Advisories.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#automated-dependency-updates-with-dependabot","title":"Automated Dependency Updates with Dependabot","text":"<p>Dependabot automates responses to alerts by generating pull requests for package updates. Contributors validate and merge these updates seamlessly.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#automated-code-scanning","title":"Automated Code Scanning","text":"<p>Similar to Dependabot, code scanning identifies vulnerabilities and errors within a GitHub repository's code. It helps fix existing issues and prevents new security problems. CodeQL empowers custom queries for tailored scanning.</p> <p>Enable code-scanning alerts and workflows in a repository's security tab.</p>"},{"location":"GitHub%20Administration%20Certification/3.%20Maintain%20a%20secure%20repository%20by%20using%20GitHub%20best%20practices/#secret-scanning","title":"Secret Scanning","text":"<p>GitHub's secret scanning detects known secrets or credentials in repositories to prevent fraud and secure sensitive data. It's enabled by default in public repositories and can be activated by administrators for private repositories.</p> <p>When secret scanning detects credentials, GitHub informs the issuing service provider for validation and appropriate action based on associated risks.</p>"},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/","title":"Manage sensitive data and security policies within GitHub","text":""},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#1-setting-security-policies","title":"1. Setting Security Policies","text":"<ul> <li>Implement security policies at various levels: repository, organization, or enterprise.</li> <li>Owners can manage access control, including enterprise-wide restrictions.</li> <li>Purpose of documentation and security settings: standardization, compliance, and prevention.</li> <li>Permission levels: None, Read, Write, Admin.</li> <li>Configuring permissions: <ul> <li>For organization: <code>Settings</code> &gt; <code>Your organization</code></li> <li>For enterprise: <code>Your enterprise</code> &gt; <code>Policies</code> &gt; <code>Repository policies</code></li> </ul> </li> <li>Configuration limited to GitHub Enterprise administrators and organization owners.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#2-documentation","title":"2. Documentation","text":"<ul> <li>Creation of default health files when starting a new repository.</li> <li>Additional default community health files:</li> <li>CODE_OF_CONDUCT.md</li> <li>CONTRIBUTING.md</li> <li>FUNDING.yml</li> <li>Issue and pull request templates and config.yml</li> <li>SECURITY.md</li> <li>SUPPORT.md</li> <li>GitHub enforces specific naming schemes for these files.</li> <li>Files contain information about security readiness, key contacts, and project background.</li> <li>Default files used if no repository-specific file exists in root, <code>.github</code>, or <code>docs</code> directories.</li> <li>SECURITY.MD is primary for security communication, includes:</li> <li>Supported project versions</li> <li>Reporting security vulnerabilities</li> <li>Possible additional information like compliance and risks.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#3-security-advisories","title":"3. Security Advisories","text":"<ul> <li>Comprehensive security advisories include:</li> <li>Affected product and version</li> <li>Severity</li> <li>Addressed security weaknesses</li> <li>Impact, patch status, and workarounds.</li> <li>Administrators publish security advisories.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#4-scrub-sensitive-data","title":"4. Scrub Sensitive Data","text":"<ul> <li>Automation:</li> <li>Pre-commit hooks</li> <li>Popular pre-commit hooks: Gitleaks, detect-aws-credentials, detect-private-key, secret_filename.</li> <li>Removing files from history:</li> <li><code>git filter-repo</code> command</li> <li><code>BFG Repo-Cleaner</code> open source tool</li> <li>Both tools rewrite history, changing SHAs of altered commits and dependent commits.</li> <li>Changed SHAs can affect open pull requests.</li> <li>Recommend merging or closing open pull requests before removing files.</li> <li>GitHub support can assist in removing confidential info.</li> </ul>"},{"location":"GitHub%20Administration%20Certification/4.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#5-reporting-and-logging","title":"5. Reporting and Logging","text":"<ul> <li>Log records capture organizational actions:</li> <li>Repository, user, action, location, date, time.</li> <li>Access log through GitHub.com, GHES, or GitHub AE (past 90 days).</li> <li>GraphQL API retrieves filtered info (past 120 days):</li> <li>Access and permission changes</li> <li>Admin promotions</li> <li>GitHub App permission changes</li> <li>REST API retrieves info (past 90 days):</li> <li>Monitors similar actions as GraphQL API</li> <li>Git events logged for 7 days</li> <li>Generate audit reports:</li> <li>Export audit logs from <code>Settings</code> &gt; <code>Your organization</code> &gt; <code>Audit log</code></li> <li>Use qualifiers for filtered results.</li> </ul> <p>For more information</p>"},{"location":"GitHub%20Administration%20Certification/5.%20Authenticate%20and%20authorize%20user%20identities%20on%20GitHub/","title":"Authenticate and authorize user identities on GitHub","text":""},{"location":"GitHub%20Administration%20Certification/6.%20GitHub%20administration%20for%20enterprise%20support%20and%20adoption/","title":"GitHub administration for enterprise support and adoption","text":""},{"location":"GitHub%20Administration%20Certification/7.%20Leverage%20GitHub%20Actions%20to%20publish%20to%20GitHub%20Packages/","title":"Leverage GitHub Actions to publish to GitHub Packages","text":""},{"location":"GitHub%20Administration%20Certification/8.%20questions/","title":"Questions / preparation","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/1.%20Introduction/","title":"1. Introduction","text":"<ol> <li> <p>Define GitHub Advanced Security</p> <ul> <li>GHAS is a licence-based service that provides a set of tools and features to help identify security vulnerabilities in codebase and environment.</li> <li>GHAS focuses on protecting three areas: supply chain, code, and environments.</li> <li>Some GHAS features are not accessible from the user interface, they work behind the scenes to improve performance of platform, such as:<ul> <li>CodeQL</li> <li>Third-part tool integration</li> </ul> </li> <li>It provides a features, such as:<ul> <li>Code scanning</li> <li>Secret scanning and additional security layers: push protection rules, environment secrets and wait timers</li> <li>Dependency graph</li> <li>Dependabot and Dependency alerts</li> <li>GHAD (GitHub Advisory Database)</li> <li>Security overview</li> <li>Code analysis</li> </ul> </li> </ul> </li> <li> <p>Identify the purpose of specific GitHub Advanced Security features</p> <ul> <li><code>GHAS</code>: Stay ahead of security threats and breaches, leverage the expertise of the security community and continue to use open-source software securely.</li> <li><code>Code scanning</code>: Identify security vulnerabilities in your codebase. Static analysis of every git push. Catch errors before they reach production.</li> <li><code>Secret scanning</code>: Prevent the fraudulent use of secrets that were committed accidentally.</li> <li><code>Dependency graph</code>: Visualize and summarize dependency data of your codebase.</li> <li><code>Dependabot</code>: Automate dependency updates. Detect vulnerable dependencies fast.</li> <li><code>Dependency alerts</code>: Get notified about vulnerable dependencies.</li> <li><code>CodeQL</code>: Engine behind code scanning that treats code like data.</li> <li><code>Third party tool integration</code>: You can integrate option third-party analysis tools that output <code>SARIF</code> data.</li> </ul> </li> <li> <p>Understand the value of a security-focused team cultrue</p> <ul> <li>Adopt security mindset</li> <li>Shift left<ul> <li>SDLC (Software Development Life Cycle), shifting left means adoption security practices early. Everyone considers security when they contribute to the code. </li> <li>By integrating security into the design phase, it makes it easier to write secure code and policies.</li> </ul> </li> <li>To achieve an ideal security model, teams should prioritize every security facet:<ul> <li><code>Scope of team involvement</code>: Teams shifting left. Each role from design to deployment is concerned with security.</li> <li><code>Prioritization</code>: Throughout all stages of development, measures are in place to protect assets</li> <li><code>Documentaiton</code>: Standards and guidelines are in writing. Teams know the process to report bugs.</li> <li><code>Tooling</code>: The development platform enforces standards and keeps code and environments secure.</li> </ul> </li> </ul> </li> <li> <p>Highlight the roles involved in securing workflow</p> <ul> <li>GitHub store security policies in repository in the <code>SECURITY.md</code> file. The file also includes instructions on reporting any bugs or vulnerabilities found in the project.</li> <li>GHAS includes compliance and policy-management features. </li> <li>Use policies to stipulate standards and procedures that keep your code healthy. </li> <li>Policies also identify who to contact when an error is found.</li> <li>Example of policies:<ul> <li>code scanning must pass before merging changes</li> <li>reviewer should approve a pull request before reviewers release it for merging</li> </ul> </li> </ul> </li> <li> <p>Recognize best practices for identifying and responding to security vulnerabilities</p> <ul> <li><code>Evaluate security alerts</code>: Reduce costs, retain customers, and protect your brand reputation when you avoid sensitive data leaks by quickly responding to security alerts.</li> <li><code>Triage security alerts</code>: Dismiss alert if it is false positive or interact with scanning alerts using pull requests. </li> <li><code>Manage security alerts</code>: Manage security alerts in your repository by prioritizing and resolving them. Use suggested fixes to have the direction to fix the issue.</li> <li><code>Use security advisories</code>: Use security advisories to securely communicate about security vulnerabilities in your project.</li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/2.%20Configure%20Dependabot%20Security%20updates%20on%20your%20GitHub%20repo/","title":"2. Configure Dependabot Security updates on your GitHub repo","text":"<ol> <li> <p>Describe the available tools for managing vulnerable dependencies on GitHub</p> <ul> <li><code>Dependency graph</code>:<ul> <li>Summary of a repository's manifest and lock files. </li> <li>Contains metadata about the project</li> <li>Is automatically generated for public repositories and includes the following information:<ul> <li>Dependencies, which are the ecosystem and packages the repository depends on.</li> <li>Dependents, which are the repositories and packages that depend on the repository.</li> </ul> </li> <li>It provides information about:<ul> <li>The direct dependencies explicitly defined in a manifest or lock file.</li> <li>The indirect dependencies, also known as transitive dependencies or subdependencies, which are dependencies used by packages that are dependencies of your project.</li> <li>The vendored dependencies that are checked into a specific directory in your repository but aren't referenced in your manifest file (only available for some package managers).</li> </ul> </li> </ul> </li> <li><code>The GitHub Advisory Database</code>:<ul> <li>Collects information on vulnerabilities and includes it in the GitHub Advisory Database.</li> <li>A curated list of security vulnerabilities related to packages tracked by GitHub dependency graph.</li> <li>Contains detailed information about each dependency including description, severity, and addicted package.</li> <li>Uses Common Vulnerability Scoring System (CVSS). Section 5, to assign a severity level to each vulnerability:; low, medium/moderate, high, critical.</li> <li>Database populates from:<ul> <li>The National Vulnerability Database.</li> <li>A combination of machine learning and human reviews to detect vulnerabilities in public commits on GitHub.</li> <li>Security advisories reported on GitHub.</li> <li>The npm Security advisories database.</li> </ul> </li> </ul> </li> <li><code>Dependabot</code>:<ul> <li>GitHub tool that automates managing your repository\u2019s dependencies.</li> <li>Requires enabled dependency graph.</li> <li>Alerts after a new vulnerability added to GHAD or dependency graph for repository chagnes.</li> <li>Uses the dependency graph and the GitHub Advisory Database to provide three features:<ul> <li>Dependabot alerts</li> <li>Security updates</li> <li>Version updates</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Enable and configure Dependabot alerts</p> <ul> <li>Enabled by default for public repositories. </li> <li>Can be enabled in <code>Settings</code> under <code>Security</code> left-side menu for private repositories.</li> <li>By default only repository owners and administrators are able to receive and dismiss alerts. Administrators and owners can grant other teams and users with access to the repository, permissions to view and dismiss alerts by selcting <code>Code securtiy and analysis</code> tab and in the <code>Access to alerts</code> section type the name of the person or team you want to grant access to. By making selection and saving changes permissions are granted.</li> </ul> </li> <li> <p>Identify the permissions and roles required to view and enable Dependabot alerts.</p> <ul> <li>Repository administrators and owners can set up Dependabot alerts for private repositories and for some GHES repositories. Enabling these features grants GitHub permission to perform read-only analysis of those specific repositories.</li> </ul> </li> <li> <p>Enable and configure Dependabot security updates.</p> <ul> <li>Dependabot security updates helps to fix the vulnerabilities identified by Dependabot alerts.</li> <li>This can be enabled in <code>Settings</code> -&gt; <code>Code security and analysis</code> tab. This will enable a manual security updates. </li> <li>Once enabled, Dependabot will create pull requests to help you keep dependencies secure and up-to-date.</li> <li>For private repositories, user should create a <code>dependabot.yml</code> file in the <code>.github</code> directory of the repository. This file will contain the configuration for Dependabot security updates. </li> <li>The <code>dependabot.yml</code> should include:<ul> <li>The <code>version</code> of the configuration file. Should be set to <code>2</code>.</li> <li>The <code>updates</code> which contains authentication details. This is optional if you have dependencies in a private registry.</li> <li>The <code>registris</code> which include an entry for each dependency you want Dependabot to monitor.</li> </ul> </li> <li> <p>For each package manager, include:</p> <ul> <li><code>package-ecosystem</code>: Specifies the package manager.</li> <li><code>directory</code>: Specifies the location of the manifest or other definition files.</li> <li><code>schedule.interval</code>: Specifies how often to check for new versions.</li> </ul> </li> <li> <p>An example of <code>dependabot.yml</code> file:     <pre><code># Basic dependabot.yml file with\n# minimum configuration for two package managers\n\nversion: 2\nupdates:\n  # Enable version updates for npm\n  - package-ecosystem: \"npm\"\n    # Look for `package.json` and `lock` files in the `root` directory\n    directory: \"/\"\n    # Check the npm registry for updates every day (weekdays)\n    schedule:\n      interval: \"daily\"\n\n  # Enable version updates for Docker\n  - package-ecosystem: \"docker\"\n    # Look for a `Dockerfile` in the `root` directory\n    directory: \"/\"\n    # Check for updates once a week\n    schedule:\n      interval: \"weekly\"\n</code></pre></p> </li> </ul> </li> <li> <p>Explain how to configure notifications for vulnerable dependencies. </p> <ul> <li>Notifications can be reviewed in <code>Security</code> tab</li> <li>GitHub notifies: owners and users with admin permissions by default.</li> <li>To reveive the notifications, admins must be watching the repository, have enabled notifications for security alerts or all activity on the repository, and must not be ignoring the repository.</li> <li>GitHub never publicly shares vulnerability information for any repository. Information is only available to repository onwers, people with admin permissions, and users who have been granted the appropriate access.</li> <li>By default, users reveive notifications in the following manner:<ul> <li>By email</li> <li>In the GitHub UI</li> <li>On the command line</li> <li>In inbox, as web notifications</li> <li>On GitHub for mobile, as web notifications</li> </ul> </li> <li>Users are also able to sync web and mobile notifications so that taking action on notification in one inbox will automatically change its status in the other. </li> <li> <p>notifications are customizable in <code>Settings</code> -&gt; <code>Notifications</code> tab. For example, users can turn off notifications from Dependabot and instead choose to receive the weekly security digest.</p> </li> <li> <p>Users are also able to triage notifications. To use the inbox, you must enable web and mobile notifications by selection <code>Web and mobile</code> notifications from the <code>Watching</code> section in <code>Manage notifications</code> &gt; <code>Notification settings</code>. </p> </li> <li>The following options are available:<ul> <li>Triage multiple notification at once</li> <li>Mark completed notifications as 'Done' and remove them from your inbox. To view all of your notifications marked as 'Done', use the is:done query.</li> <li>Save a notification to review later. Saved notifications are flagged in your inbox and kept indefinitely. To view all of your saved notifications, use the is:saved query.</li> <li>Unsubscribe and remove a notification from your inbox.</li> <li>Preview the issue, pull request, or team discussion where the notification originates from on GitHub.com from within the notifications inbox.</li> <li>See one of the latest reasons you're receiving a notification from your inbox with a reasons label.</li> <li>Create custom filters to focus on different notifications when you want.</li> <li>Group notifications in your inbox by repository or date to get a quick overview with less context switching.</li> </ul> </li> </ul> </li> <li> <p>Explain how to use GraphQL API to retrieve vulnerability information.</p> <ul> <li>Users are able to use GraphQL API to retrieve and export Dependabot alert information.</li> <li>GraphQL API enables you to export a list of your dependencies that can be saved as a CSV and then imported into a Business Intelligence tool for analysis.</li> <li>Requires a OAuth token with the following scopes to communicate with the GraphQL server:<ul> <li><code>user</code></li> <li><code>public_repo</code></li> <li><code>repo</code></li> <li><code>repo_deployment</code></li> <li><code>repo:status</code></li> <li><code>read:repo_hook</code></li> <li><code>read:org</code></li> <li><code>read:public_key</code></li> <li><code>read:gpg_key</code></li> </ul> </li> <li> <p>GraphQL has a single endpoint, that doesn't change: <code>https://api.github.com/graphql</code></p> </li> <li> <p>GraphQL Explorer is the recommended tool for communicating with the GraphQL API.</p> </li> <li>It is a graphical interactive in-browser GraphQL IDE tool. The Explorer is an instance of GraphiQL. </li> <li>GraphQL queries return only the data you specify. The structure is:     <pre><code>query {\nJSON objects to return\n}\n</code></pre></li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/3.%20Configure%20and%20use%20secret%20scanning%20in%20GitHub%20repository/","title":"3. Configure and use secret scanning in GitHub repository","text":"<ol> <li> <p>Describe secret scanning</p> <ul> <li>Secret scanning is a GHAS feature that scans repositories for known types of secrets. It prevents the fraudulent use of secrets that were committed accidentally.</li> <li>GitHub also notifies the service provider who issued the secret.</li> <li>It automatically scans entire Git history on all branches present in GitHub repository for any secrets. </li> <li>If found - sends notification to all repository administrators about the commit that contains the secret.</li> <li>This feature is available for all public repositories and cannot be configured or turned off, for private repos it requires an enabled GHAS plan and must be enabled manually.</li> </ul> </li> <li> <p>Configure secret scanning</p> <ul> <li>For private repos, secret scanning has a few configurable parameters:<ul> <li>excluding files from being scanned</li> <li>configurable notification recipients</li> </ul> </li> <li>To exclude files from being scanned, create <code>.github/secret_scanning.yml</code> file in the repository. To exclude files, use <code>paths-ignore</code> syntax:     <pre><code>paths-ignore:\n- \"foo/bar/*.js\"\n</code></pre><ul> <li>If there are more than 1000 entries in <code>path-ignore</code>, secret scanning will only exclude the first 1000 from scans.</li> <li>If <code>secret-scanning.yml</code> is larger than <code>1 MB</code>, secret scanning will ignore the entire file.</li> <li>Users can also use special characters, such as <code>*</code> to filter paths.</li> </ul> </li> <li>GitHub notifies the following users of secret scanning alerts on a repository:<ul> <li>Repository admins</li> <li>Organization owners</li> <li>Authors of commits that trigger alerts</li> </ul> </li> <li>To configure recipients of secret scanning alerts, go to <code>Settings</code> &gt; <code>Security &amp; analysis</code> &gt; add recipients into <code>Search for people or teams</code> field &gt; click <code>Save</code>.</li> </ul> </li> <li> <p>Use secret scanning</p> <ul> <li>Respond to alert:<ul> <li>For a compromised GitHub personal access token, delete the compromised token, create a new token, and update any services that use the old token.</li> <li>For all other secrets, first verify that the secret committed to GitHub is valid. If so, create a new secret, update any services that use the old secret, and then delete the old secret.</li> </ul> </li> <li>Create a custom pattern:<ul> <li>You can define up to 500 custom patterns for each organization or enterprise account, and up to 100 custom patterns per private repository.</li> <li>After pattern created, secret scanning will scan for the custom secret in private repositories in your organization.</li> </ul> </li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/4.%20Configure%20code%20scanning%20on%20GitHub/","title":"4. Configure code scanning on GitHub","text":"<ol> <li> <p>Describe code scanning</p> <ul> <li>Uses CodeQL to analyze the code in a GitHub repository to find security vulnerabilities and coding errors</li> <li>Available for all public repositories, and for private repositories owned by organizations where GHAS is enabled</li> <li>If error is found, it will be displayed in the <code>Security</code> tab of the repository.</li> <li>After error is fixed, GitHub will close the alert</li> </ul> </li> <li> <p>About code scanning with CodeQL</p> <ul> <li>Two main ways to use CodeQL analysis for code scanning:<ul> <li>Add the CodeQL workflow to your repository using <code>github/codeql-action</code> to run the CodeQL CLI</li> <li>Run the CodeQL CLI directly in an external CI system and upload the results to GitHub</li> </ul> </li> <li>It treats code like data, allowing to find potential vulnerabilities in code with greated queries on that database to identify problems in the codebase.</li> <li>CodeQL supports both compiled and interpreted languages:<ul> <li>C/C++/C#</li> <li>Go</li> <li>Java</li> <li>JavaScript/TypeScript</li> <li>Python</li> <li>Ruby</li> </ul> </li> <li>Running code scanning with GitHub Actions will affect your monthly billing minutes. If you want to use GitHub Actions beyond the storage or minutes included in your account, you'll be billed for additional usage.</li> </ul> </li> <li> <p>Contrast how to implement CodeQL analysis in a GitHub Actions workflow versus a third party continuous integration (CI) tool</p> <ul> <li>Use code scanning API endpoints to create automated reports for the code scanning alerts in an organization or upload results generated using offline code scanning tools</li> <li>Supported custom media type for the code scanning REST API is <code>application/sarif+json</code></li> <li>The data is formatted as SARIF version 2.1.0</li> <li>endpoint can be <code>/analyses/{analysis_id}</code>. This endpoint includes additional data such as:<ul> <li><code>github/alertNumber</code></li> <li><code>github/alertUrl</code></li> </ul> </li> <li>CodeQL can be used by:<ul> <li>public repositories that are maintained on GitHub.com</li> <li>private repositories that are owned by customers with an Advanced Security license</li> </ul> </li> <li>CodeQL comes with a bundle. The bundle contains:<ul> <li>CodeQL CLI product</li> <li>A compatible version of the queries and libraries from <code>github.com/github/codeql</code></li> <li>Precompiled versions of all the queries included in the bundle</li> </ul> </li> <li>GitHub recommends using CodeQL bundle as this ensures compatibility and also gives much better performance that a separate download of the CodeQL CLI and checkout of the CodeQL queries.</li> <li>Configuring Code scanning with GitHub Actions:<ul> <li>To enable code scanning with a GitHub Actions, you must specify <code>upload-sarif</code> action, which is a part of the <code>github/codeql-action</code> repository. This workflow includes input parameters that you can use to configure the upload</li> <li>The main input is <code>sarif-file</code>, which configures the file or directory of SARIF files to be uploaded.</li> <li>The <code>upload-sarif</code> action can be configured to run when the <code>push</code> and <code>scheduled</code> event occures</li> <li>An example configuration: <pre><code>name: 'Code Scanning : Upload SARIF'\ndescription: 'Upload the analysis results'\nauthor: 'GitHub'\ninputs:\n  sarif_file:\n    description: |\n      The SARIF file or directory of SARIF files to be uploaded to GitHub code      scanning.\n      See https://docs.github.com/en/code-security/code-scanning/       integrating-with-code-scanning/\n      uploading-a-sarif-file-to-github#uploading-a-code-scanning-analysis-with-githu        b-actions\n      for information on the maximum number of results and maximum file size        supported by code scanning.\n    required: false\n    default: '../results'\n  checkout_path:\n    description: \"The path at which the analyzed repository was checked out. \n    Used to relativize any absolute paths in the uploaded SARIF file.\"\n    required: false\n    default: ${{ github.workspace }}\n  token:\n    default: ${{ github.token }}\n  matrix:\n    default: ${{ toJson(matrix) }}\n  category:\n    description: String used by Code Scanning for matching the analyses\n    required: false\n  wait-for-processing:\n    description: If true, the Action will wait for the uploaded SARIF to be         processed before completing.\n    required: true\n    default: \"false\"\nruns:\n  using: 'node12'\n  main: '../lib/upload-sarif-action.js'\n</code></pre></li> <li>GitHub uses properties in the SARIF file to display alerts.</li> <li>Code scanning uses fingerprints to prevent duplicate alerts.</li> <li>SARIF files creqted by CodeQL include the fingerprint data in the <code>partialFingerprints</code> field.</li> <li>SARIF upload supports a maximum of 5000 results per upload. Any results over this limit will be ignored. In order to fix it, the configuration should be updated to focus on results for the most important rules or queries.</li> <li>For each upload, SARIF supports a maximum size of 10 MB for the gzip-compressed SARIF file</li> <li>You can also create a new workflow that uploads SARIF files after you commit them to your repository. This is useful when the SARIF file is generated as an artifact outside of your repository.</li> <li>A second example of using SARIF files which generated outside repository: <pre><code>name: \"Upload SARIF\"\n\n// Run workflow each time code is pushed to your repository and on a schedule. \n//The scheduled workflow runs every Thursday at 15:45 UTC.\n\non:\n  push:\n  schedule:\n    - cron: '45 15 * * 4'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n  steps:\n    # This step checks out a copy of your repository.\n    - name: Checkout repository\n      uses: actions/checkout@v2\n    - name: Upload SARIF file\n      uses: github/codeql-action/upload-sarif@v1\n      with:\n        # Path to SARIF file relative to the root of the repository\n        sarif_file: results.sarif\n</code></pre></li> <li>To generate third-part SARIF file as part of CI workflow, you can add the <code>upload-sarif</code> action as a step after running CI tests. </li> <li>An example of uploading SARIF files generated as part of a CI workflow: <pre><code>  name: \"ESLint analysis\"\n\n// Run workflow each time code is pushed to your repository and on a schedule.\n// The scheduled workflow runs every Wednesday at 15:45 UTC.\non:\n  push:\n  schedule:\n    - cron: '45 15 * * 3'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      security-events: write\n    steps:\n      - uses: actions/checkout@v2\n      - name: Run npm install\n        run: npm install\n      // Runs the ESlint code analysis\n      - name: Run ESLint\n        // eslint exits 1 if it finds anything to report\n        run: node_modules/.bin/eslint build docs lib script spec-main -f node_modules/@microsoft/eslint-formatter-sarif/sarif.js -o results.sarif || true\n      // Uploads results.sarif to GitHub repository using the upload-sarif action\n      - uses: github/codeql-action/upload-sarif@v1\n        with:\n          // Path to SARIF file relative to the root of the repository\n          sarif_file: results.sarif\n</code></pre></li> <li>By default, the workflow file for the CodeQL code scanning is called <code>codeql-analysis.yml</code>.</li> </ul> </li> </ul> </li> <li> <p>Explain how to configure code scanning on a repository using triggering events</p> <ul> <li>Configure frequency<ul> <li>scan on schedule</li> <li>scan on push</li> <li>scan on pull request</li> </ul> </li> <li>Define the secerities causing pull request check failure:<ul> <li>By default, onlt alerts with the severity level of <code>Error</code> or security level of <code>Critical</code> or <code>Hight</code> will cause a pull request check failure.</li> <li>Pull request failure don't stop a code scan, but represent a blocker when trying to merge code.</li> <li>This can be changed in <code>Settings</code> &gt; <code>Security &amp; Analysis</code> &gt; <code>Code scanning</code> section</li> </ul> </li> <li>To avoid unnecessary scand of pull requrest, use <code>paths-ignore</code> keyword. For example to exclude .md and .txt files from being scanned: <pre><code>on:\n   push:\n      branches: [main, protected]\n   pull_request:\n      branches: [main]\n      paths-ignore:\n         - '**/*.md'\n         - '**/*.txt'\n</code></pre></li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/5.%20Code%20Scanning%20with%20GitHub%20CodeQL/","title":"5. Code Scanning with GitHub CodeQL","text":"<ol> <li> <p>Understand CodeQL and how it analyzes code.</p> <ul> <li>Consists of three steps:<ul> <li>Preparing the code, by creating a CodeQL database</li> <li>Running CodeQL queries against the database</li> <li>Interpreting the results</li> </ul> </li> <li>Database creation:<ul> <li>CodeQL first extracts a single relational representation of each source file in the codebase</li> <li>For compiled languages, extraction works by monitoring the build process and itincludes a syntatic data about the abstract syntax tree and semantic data about name binding and type information</li> <li>For interpreted languages, extractor runs on the source code, resolving dependencies to give an accurate representation of the codebase</li> <li>There is one extractor for each language supported by CodeQL</li> <li>For multi-language codebases, databases are generated one language at a time</li> <li>After extraction, all the data required for analysis is imported into a single directory, known as the CodeQL database</li> </ul> </li> <li>Query execution:<ul> <li>After database creation, one or more queries are executed against it</li> <li>CodeQL queries are written in QL language</li> <li>You can run the queries checked out from the CodeQL repo using the CodeQL for VS Code extension or the CodeQL CLI.</li> </ul> </li> <li>Query results:<ul> <li>Queries contain metadata properties that indicate how the results should be interpreted.</li> <li>results are output for code review and triaging. </li> <li>In CodeQL for Visual Studio Code, interpreted query results are automatically displayed in the source code. </li> <li>You can output results generated by the CodeQL CLI into a number of different formats for use with different tools.</li> </ul> </li> </ul> </li> <li> <p>Understand QL, a unique logic programming language.</p> <ul> <li>Analysis engine used to automate security checks</li> <li>Variant analysis:<ul> <li>the process of using a known security vulnerability such as a seed to find similar problems in the code</li> <li>Querying code using CodeQL is the most efficient way to perform variant analysis</li> </ul> </li> <li>CodeQL databases:<ul> <li>contain queryable data extracted from a codebase, for a single language at a particular point in time</li> <li>contains a full hierarchical representation of the code, including representation of the abstract syntax tree, the data-flow graph, and the control-flow graph</li> <li>Each language has its own database schema that defines the relations used to create a database</li> </ul> </li> <li>Query suites<ul> <li>Allows to pass multiple queries to CodeQl</li> <li>No need to specify the path to each query individually</li> <li>Definitions stored in a YAML file, with the <code>.qls</code> extension</li> <li>a sequence of instructions where each instruction is a YAML mapping with (usually) as single key</li> </ul> </li> <li>Default query suites:<ul> <li><code>code-scannig</code>: queries run by default in CodeQL code scanning on GitHub.</li> <li><code>security-extended</code>: queries from <code>code-scanning</code>, plus extra security queries with slightly lower precision and severity.</li> <li><code>security-and-quality</code>: queries from <code>code-scanning</code>, <code>security-extended</code>, plus extra maintainability and reliability queries.</li> </ul> </li> <li>Query Language (QL) packs:<ul> <li>Packs contain queries, libraries, query suites, and important metadata</li> <li>CodeQL contains QL packs for C/C++, C#, Java, JavaScript, Python, and Ruby</li> <li>for Go, repository contains a QL pack for Go analysis</li> <li>Users are also able to make custom QL packs</li> </ul> </li> <li>QL pack structure:<ul> <li>Must contain a file called <code>qlpack.yml</code> in its root directory</li> <li>Should be well orgaized:<ul> <li>Queries are organized into directories for specific categories.</li> <li>Queries for specific products, libraries, and frameworks are organized into their own top-level directories.</li> <li>There is a top-level directory named <code>&lt;owner&gt;/&lt;language&gt;</code> for query library (.qll) files. Within this directory, .qll files should be organized into subdirectories for specific categories.</li> </ul> </li> <li>An example of <code>qlpack.yml</code>:     <pre><code>name: codeql/java-queries\nversion: 0.0.6-dev\ngroups: java\nsuites: codeql-suites\nextractor: java\ndefaultSuiteFile: codeql-suites/java-code-scanning.qls\ndependencies:\n    codeql/java-all: \"*\"\n    codeql/suite-helpers: \"*\"\n</code></pre></li> </ul> </li> </ul> </li> <li> <p>Configure code scanning:</p> <ul> <li>4 ways:<ul> <li>CodeQL: GitHub Actions</li> <li>CodeQL: in a third-party CI system</li> <li>Third-party: GitHub Actions</li> <li>Third-party: Generated externally and then uploaded to GitHub</li> </ul> </li> <li>There are two options for specifying which queries to run with CodeQl code scanning:<ul> <li>Using code scanning workflow</li> <li>Using a custom configuration file</li> </ul> </li> <li>The options to specify the additional queries are:<ul> <li><code>packs</code> to install one or more CodeQL query packs and run the default query suite for these packs.</li> <li><code>queries</code> to specify a single <code>.ql</code> file, a directory containing multiple <code>.ql</code> files, a <code>.qls</code> query suite definition file, or any combination.</li> </ul> </li> <li>It is possible to use both packs and queries in the same workflow.</li> <li>GitHub don't recommend referencing quiry suites directly from the github/codeql repository, like <code>github/codeql/cpp/ql/src@main</code>. Such queries may not be complied with the same version of CodeQL as used for other queries, which could lead to errors during analysis.</li> <li>Use CodeQL query packs:<ul> <li>To add one or more CodeQL query packs, add <code>with: packs:</code> entry within the <code>uses: github/codeql-action/init@v1</code> section of the workflow.</li> <li><code>GITHUB_TOKEN</code> environment variable is required in ordet to use packages that aren't publicly available.</li> <li>An example:     <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    # Comma-separated list of packs to download\n    packs: scope/pack1,scope/pack2@1.2.3,scope/pack3@~1.2.3\n</code></pre></li> </ul> </li> <li>Use queries in QL packs:<ul> <li>To add one or more queries, add w <code>with: queries:</code> entry within the <code>uses: github/codeql-action/init@v1</code> section of the workflow.</li> <li>If queries are in a private repository, use the <code>external-repository-token</code> parameter to specify a token that has access token that has access to check out the private repository. <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    queries: COMMA-SEPARATED LIST OF PATHS\n    # Optional. Provide a token to access queries stored in private repositories.\n    external-repository-token: ${{ secrets.ACCESS_TOKEN }}\n</code></pre></li> <li>You can also specify query suites in the value of queries.</li> <li>Query suites are collections of queries, usually grouped by purpose or language.</li> <li>The following query suites are built into CodeQL code scanning:<ul> <li><code>code-scanning</code>: queries run by default in CodeQL code scanning on GitHub.</li> <li><code>security-extended</code>: queries of lower severity and precision than the default queries</li> <li><code>security-and-quality</code>: queries from security-extended, plus maintainability and reliability queries.</li> </ul> </li> </ul> </li> <li>Combining queries from a workflow file and a custom configuration file:<ul> <li>If you also use a configuration file for custom settings, any additional packs or queries specified in your workflow are used instead of those specified in the configuration file. If you want to run the combined set of additional packs or queries, prefix the value of packs or queries in the workflow with the <code>+</code> symbol: <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    config-file: ./.github/codeql/codeql-config.yml\n    queries: +security-and-quality,octo-org/python-qlpack/show_ifs.ql@main\n    packs: +scope/pack1,scope/pack2@v1.2.3`\n</code></pre></li> </ul> </li> <li>Additional queries in a custom configuration file:<ul> <li>In the workflow file, use the <code>config-file</code> paratemeter of the <code>init</code> action to specify the configuration file you want to use: <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    config-file: ./.github/codeql/codeql-config.yml\n</code></pre></li> <li>Configuration file can be located within the repository or in an external repository.</li> <li>In order to reference configuration file located in external repository, use <code>OWNER/REPOSITORY/FILENAME@BRANCH</code> syntax. For example: <code>octo-org/shared/codeql-config.yml@main</code></li> <li>If configuration is located in an external private repository, use <code>external-repository-token</code> parameter of the <code>init</code> action to specify a token that has access to the private repository. <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    external-repository-token: ${{ secrets.ACCESS_TOKEN }}\n</code></pre></li> </ul> </li> <li>Specify CodeQL query packs in custom configuration files:<ul> <li>Query can be specified in an array: <pre><code>packs:\n  # Use the latest version of 'pack1' published by 'scope'\n  - scope/pack1\n  # Use version 1.23 of 'pack2'\n  - scope/pack2@v1.2.3\n  # Use the latest version of 'pack3' compatible with 1.23\n  - scope/pack3@~1.2.3\n</code></pre></li> <li>If workflow generates more than one CodeQL database, you can specify any CodeQL query packs to run in a custom configuration file using a nested map of packs <pre><code>packs:\n  # Use these packs for JavaScript analysis\n  javascript:\n    - scope/js-pack1\n    - scope/js-pack2\n  # Use these packs for Java analysis\n  java:\n    - scope/java-pack1\n    - scope/java-pack2@v1.0.0\n</code></pre></li> </ul> </li> <li>Specify additional queries in custom configuration:<ul> <li>Can be specified in a queries array</li> <li>Each element of array contains a uses parameter with a value that identifies a single query file, a directory containing query files, or a query suite definition: <pre><code>name: \"My CodeQL config\"\n\ndisable-default-queries: true\n\nqueries:\n  - name: Use an in-repository QL pack (run queries in the my-queries directory)\n    uses: ./my-queries\n  - name: Use an external JavaScript QL pack (run queries from an external repo)\n    uses: octo-org/javascript-qlpack@main\n  - name: Use an external query (run a single query from an external QL pack)\n    uses: octo-org/python-qlpack/show_ifs.ql@main\n  - name: Use a query suite file (run queries from a query suite in this repo)\n    uses: ./codeql-qlpacks/complex-python-qlpack/rootAndBar.qls\n\npaths:\n  - src\npaths-ignore:\n  - src/node_modules\n  - '**/*.test.js'\n</code></pre></li> </ul> </li> <li>Disabling default queries:<ul> <li>To disable default queries, use <code>disable-default-queries: true</code> syntax.</li> <li>This syntax should be used to construct a custom query suite that excludes a particular rule. (to avoid having all of the queries run twice)</li> </ul> </li> <li>Specify directories to scan:<ul> <li>To specify directories to scan, use <code>paths</code> and <code>paths-ignore</code> parameters. <pre><code>paths:\n  - src\npaths-ignore:\n  - src/node_modules\n  - '**/*.test.js'\n</code></pre></li> <li>The paths and paths-ignore keywords, used in the context of the code scanning configuration file, should not be confused with the same keywords when used for <code>on.&lt;push|pull_request&gt;.paths</code> in a workflow. When they're used to modify <code>on.&lt;push|pull_request&gt;</code> in a workflow, they determine whether the actions will be run when someone modifies code in the specified directories.</li> <li>The filter pattern characters ?, +, [, ], and ! aren't supported and will be matched literally.</li> <li>** characters can only be at the start or end of a line, or surrounded by slashes, and you can't mix ** and other characters. For example: <code>foo/**</code>, <code>**/foo</code>, and <code>foo/**/bar</code> are all allowed syntax, but **foo isn't. However ,you can use single stars along with other characters, as shown in the example. You'll need to quote anything that contains a * character.</li> </ul> </li> </ul> </li> <li> <p>Using CodeQL CLI:</p> <ul> <li>CodeQL CLI commands:<ul> <li><code>database create</code>: to create a CodeQL database</li> <li><code>database analyze</code>: to run queries against a database</li> <li><code>github upload-results</code>: to upload results (SARIF files) to GitHub</li> <li><code>--help</code>: to get help command-line options</li> </ul> </li> <li>Create CodeQL databases to analyze:<ul> <li>Checkout the code to analyze &gt; set up the environment of the codebase &gt; find the build command &gt; run <code>codeql database create</code> command:<ul> <li>to create one CodeQL database for a single supported language, use: <pre><code>codeql database create &lt;database&gt; --command&lt;build&gt; --language=&lt;language-identifier&gt;\n</code></pre></li> <li>to create one CodeQL database per language for multiple supported languages, use: <pre><code>codeql database create &lt;database&gt; --command&lt;build&gt; \\\n--db-cluster --language=&lt;language-identifier&gt;,&lt;language-identifier&gt;\n</code></pre></li> <li>If you use a containerized build, you need to run the CodeQL CLI inside the container where you build task takes place.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>CodeQL and matrix:</p> <ul> <li>Recommended by GitHub due to the performance benefits of parallelizing builds: <pre><code>jobs:\n  analyze:\n    name: Analyze\n    ...\n    strategy:\n      fail-fast: false\n      matrix:\n        language: ['javascript', 'python']\n</code></pre></li> <li>If workflow doesn't contain a matrix called <code>language</code>, then CodeQL will run analysis sequentially. </li> <li>If languages are not specified in the workflow, CodeQL detects and attempts to analyze any supported languages in the repository.</li> <li>In order to analyze specific languages without using a matrix, you can use the languages parameter under the <code>init</code> action: <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    languages: cpp, csharp, python\n</code></pre></li> <li>If the C/C++, C#, or Java code in your repository has a non-standard build process, autobuild may fail. You will need to remove the <code>autobuild</code> step from the workflow, and manually add build steps. <pre><code>- if: matrix.language == 'cpp' || matrix.language == 'csharp'\n  name: Autobuild\n  uses: github/codeql-action/autobuild@v1\n\n- if: matrix.language == 'java'\n  name: Build Java\n  run: |\n    make bootstrap\n    make release\n</code></pre></li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/6.%20Identify%20security%20vulnerabilities%20in%20your%20codebase%20with%20CodeQL/","title":"6. Identify security vulnerabilities in your codebase with CodeQL","text":"<ol> <li> <p>Create a database by using CodeQL to extract a single relational representation of each source file in the codebase</p> <ul> <li>Download the ZIP archive of the CodeQL CLI, this can be:<ul> <li><code>codeql-PLATFORM.zip</code> with the specific platform (OS)</li> <li><code>codeql.zip</code> with contains all of the platforms CodeQL supports</li> </ul> </li> <li>Create a new CodeQL directory:<ul> <li><code>$HOME/codeql-home</code></li> </ul> </li> <li>Obtain a local copy of the CodeQL queries:<ul> <li>clone a copy of the repository into CodeQL directory <code>codeql-home</code></li> <li>the root of the cloned repository will be called <code>codeql</code> by default</li> <li>After cloning, rename the folder <code>codeql-repo</code>, so that it wouldn't conflict with the CodeQL CLI</li> </ul> </li> <li>Extract the zip archive:<ul> <li>If you are using Windows, Linux or macOS, you can extract the archive into the <code>$HOME/codeql-home</code> directory</li> <li>example: <code>$HOME/codeql-home/codeql-repo</code></li> </ul> </li> <li> <p>Launch <code>codeql</code>:</p> <ul> <li>Execute <code>&lt;extraction-root&gt;/codeql/codeql</code>, where <code>&lt;extraction-root&gt;</code> is the folder where CodeQL CLI package been extracted</li> <li>add <code>&lt;extraction-root&gt;/codeql</code> to your <code>PATH</code> to execute just using <code>codeql</code> command</li> </ul> </li> <li> <p>CodeQl CLI commands:</p> <ul> <li><code>codeql resolve languages</code>: list the languages that are available for database creation</li> <li><code>codeql resolve qlpacks</code>: show which QL packs the CLI can find<ul> <li>Packs includes: <code>codeql-cpp</code>, <code>codeql-csharp</code>, <code>codeql-go</code>, <code>codeql-java</code>, <code>codeql-javascript</code>, and <code>codeql-python</code></li> </ul> </li> </ul> </li> <li>To create database, use: <code>codeql database create &lt;database&gt; --language=&lt;language-identifier&gt;</code><ul> <li><code>&lt;database&gt;</code>: path to the new database to be created</li> <li><code>--language</code>: the identifier for the language used to create the database</li> </ul> </li> <li>You can also create a new directory that include the CLI and any queries        </li> <li>You are able to use extractors:<ul> <li><code>codeql resolve extractor --format=betterjson</code></li> <li>To find which options are availabe for language, use <code>codeql resolve languages --format=betterjson</code> or <code>codeql resolve extractor --format=betterjson</code>. This gives the extractor's root and other language specific options.</li> </ul> </li> <li>CodeQL database provides:<ul> <li>full, hierarchical representation of the code</li> <li>represintation of the abstract syntax tree</li> <li>the data flow graph</li> <li>the control flow graph</li> </ul> </li> <li>Database schema includes:<ul> <li><code>expressions</code> table, which contains a row for every expression in the source code that was analyzed during the build process</li> <li><code>statements</code> table, which contains a row for every statement in the source code that was analyzed during the build process</li> </ul> </li> <li>CodeQL library defines classes to provide a layer of abstraction over the each of these tables. This includes the related auxuliary tables <code>Expr</code> and <code>Stmt</code>.</li> </ul> </li> <li> <p>Run CodeQL in a database to find problems in your source code and find potential security vulnerabilities</p> <ul> <li>After creating a database, you can make queries. There are two types of queries:<ul> <li><code>Alert queries</code>: highlight issues in specific location of the code</li> <li><code>Path queries</code>: describe the flow of information between a source and a sink in the code</li> </ul> </li> <li>Writing simple query:<ul> <li>Basic query structure has the file extension <code>.ql</code> and contains a <code>select</code> clause</li> <li>An example of structure: <pre><code>/**\n *\n * Query metadata\n *\n */\nimport /* ... CodeQL libraries or modules ... */\n/* ... Optional, define CodeQL classes and predicates ... */\nfrom /* ... variable declarations ... /\nwhere / ... logical formula ... /\nselect / ... expressions ... */\n</code></pre></li> </ul> </li> </ul> </li> <li> <p>Troubleshoot CodeQL results:</p> <ul> <li>You need to optimize CodeQL, if CodeQL taking too long to complete:<ul> <li>If you use self-hosted runners for CodeQL analysis, you can increase the memory or the number of cores.</li> <li>The analysis of each language runs in parallel with the default CodeQL analysis workflow in order to build a matrix of languages. You can modify your workflow to use a matrix that speeds up the analysis of multiple languages.</li> <li>The amount of code being analyzed may cause long runtimes. Analysis time is typically proportional to the amount of code being analyzed. You can reduce the size of the code by excluding test code or breaking the code into multiple workflows to only analyze a subset with each scan.</li> <li>You may want to only trigger analysis on the schedule event if your analysis is too slow while running during <code>push</code> or <code>pull_request</code> events.</li> </ul> </li> <li>Analysis is failing? Check following:<ul> <li>If Dependabot authored the commit</li> <li>If the pull request that includes the commit has been merged using <code>@dependabot squash and merge</code></li> <li>To solve it, enable auto-merge for your repository</li> </ul> </li> <li>Best practices:<ul> <li>Eliminate cartesian products</li> <li>Use specific types</li> <li>Determine the nist soecufuc types of a variable</li> <li>Avoid comple recursion</li> <li>Fold predicates:<ul> <li>linear, prevents too much branching</li> <li>tightly bount, the chunks join with each other on as many variables as possible</li> </ul> </li> <li>Debug data-flow queries using partial flow</li> <li>Debug artifacts</li> <li>Troubleshoot CodeQL for VS Code</li> </ul> </li> <li>Common error messages:<ul> <li><code>Server error</code>: Try running the workflow again if the run of a workflow for code scanning fails due to a server error.</li> <li><code>Out of disk</code> or <code>out of memory</code>: Contact GitHub Support so that they can investigate this type of issue on a hosted GitHub Actions runner.</li> <li><code>403 Resource not accessible by integration</code>: Use <code>pull_request</code> event instead of <code>push</code> event.</li> <li><code>git checkout HEAD^2 is no longer necessary</code>: use <code>github/checkout</code> action instead of using <code>git checkout HEAD^2</code> in your workflow.</li> </ul> </li> <li>Important to keep in mind:<ul> <li>CodeQL predicates and classes are evaluated to database tables.</li> <li>Large predicates generate large tables with many rows, and are therefore expensive to compute</li> <li>The QL language is implemented using standard database operations and relational algebra, such as join, projection, and union.</li> <li>Queries are evaluated bottom-up, which means that a predicate is not evaluated until all of the predicates that it depends on are evaluated.</li> </ul> </li> <li>Also nice to know:<ul> <li>You may see different results depending on whether you run the CodeQL analysis workflow on Linux, macOS, or Windows, or if you're analyzing code written in Python.</li> <li>The CodeQL analysis workflow tries to install and analyze Python dependencies, which could lead to more results on GitHub-hosted runners that use Linux. To disable the auto-install, add <code>setup-python-dependencies: false</code> to the \"Initialize CodeQL\" step of the workflow.</li> </ul> </li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/7.%20GitHub%20administration%20for%20GitHub%20Advanced%20Security%20/","title":"7. GitHub administration for GitHub Advanced Security","text":"<ol> <li> <p>Understand what GitHub Advanced Security is and how to leverage it in the software development lifecycle.</p> <ul> <li>By shifting left you leveraging Security in project during whole development lifecycle.</li> <li>You are able to use <code>security policies</code> during the project configuration. <code>code scanning</code>, <code>secret scanning</code> and <code>dependency review</code> during the Code Review phase, and <code>code scanning</code> during the CI/testing phase.</li> <li>This makes the quality assurance phase easier, because the code has already been reviewed multiple times.</li> </ul> </li> <li> <p>Identify which GitHub Advanced Security features are available for open-source projects and which are available on enterprise products.</p> <ul> <li>All of the features are available with Advanced security license for both public and private repositories without any limitations. The availability of the features described below without having a GHAS license plan enabled:<ul> <li><code>Code scanning</code>: Automatically detect common vulnerabilities and coding errors. Available for public repositories. Unavailable for private repositories. </li> <li><code>Secret scanning</code>: Receive alerts when secrets or keys are checked in, exclude files from scanning, and define up to 100 custom patterns. Available for public repositories with limited functionality only. Unavailable for private repositories.</li> <li><code>Dependency review</code>: Show the full impact of changes to dependencies and see details of any vulnerable versions before you merge a pull request. Available for public repositories. Unavailable for private repositories.</li> <li><code>Security overview</code>: Review the security configuration and alerts for an organization and identify the repositories at greatest risk. Unavailable for public and private repositories. </li> </ul> </li> </ul> </li> <li> <p>Enable the different features of GitHub Advanced Security on different enterprise products.</p> <ul> <li>Enabling <code>GHAS</code> for <code>GHEC</code>:<ol> <li><code>Settings</code> &gt; <code>Code security and analysis</code></li> <li><code>Configure security and analysis features</code> &gt; <code>Enable all</code> next to <code>GitHub Advanced Security</code></li> <li>Review the impact and click <code>Enable all</code></li> <li>To automatically enable <code>GHAS</code> on new private and internal repositories, select <code>Automatically enable for new private and internal repositories</code> checkbox</li> </ol> </li> <li>Enabling <code>GHAS</code> for <code>GHES</code>:<ul> <li>Can be done using <code>GitHub UI</code> or <code>SSH</code></li> <li>Make sure that:<ul> <li>License for GHES been upgraded to include GHAS</li> <li>You reviewed prerequisites for the features you plan to enable. (Prerequisites for code scanning, secret scanning and Dependabot)</li> <li>Enabling GitHub Advanced Security features on your Enterprise Server instance will cause user-facing services on GitHub Enterprise Server to restart. You should time this change carefully to minimize downtime for users.</li> </ul> </li> <li>Enabling using SSH:<ul> <li>SSH into your GitHub Enterprise Server instance.</li> <li>Enable the GitHub Advanced Security features you want to implement in your instance:<ul> <li>To enable code scanning, enter <code>ghe-config app.minio.enabled true</code> followed by <code>ghe-config app.code-scanning.enabled true</code></li> <li>To enable secret scanning, enter <code>ghe-config app.secret-scanning.enabled true</code></li> <li>To enable the dependency graph, enter <code>ghe-config app.dependency-graph.enabled true</code></li> </ul> </li> </ul> </li> <li>Enable using UI:<ul> <li><code>Site adming</code> page &gt; <code>Management Console</code> &gt; <code>Security</code></li> <li>Under <code>Security</code>, select the features to enable:<ul> <li><code>Dependency graph</code></li> <li><code>Code scanning</code></li> <li><code>Secret scanning</code></li> <li>Click <code>Save Settings</code></li> </ul> </li> </ul> </li> <li>After Enabling GHAS, it will restart the instance. </li> <li>Now you should follow the same steps that described for <code>GHEC</code> to enable GHAS for all the repositories in your organization.</li> </ul> </li> </ul> </li> <li> <p>Determine who should get access to GitHub Advanced Security features in an organization and grant the correct permissions.</p> <ul> <li>Managing access to security alerts:<ul> <li><code>Code scanning alerts</code>: requires <code>write</code> permission on repository.</li> <li><code>Secret scanning alerts</code>: requires repository administrators and organization owners permissions.</li> <li><code>Dependabot alerts</code>: Repository administrators and organization owners permissions.</li> <li>Repository administrators and organization owners can give <code>secret scanning</code> and <code>dependabot alert</code> access to users and teams with write permission on their repositories from the repository <code>Security and analysis</code> settings.<ul> <li>For <code>code scanning</code>: users with permissions are able to dismiss alerts that do not require any action, or delete alerts to clean up <code>code scanning</code> results.</li> <li>For <code>secret scanning</code>: users with permissions are able to delete detected secrets, create new tokens and update code that uses the detected secrets, or dismiss alerts that do not require any action.</li> <li>For <code>dependabot alerts</code>: users with permissions are able update vulnerable dependencies, or dismiss alerts that do not require any action.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Set security policies at the organization and repository levels.</p> <ul> <li>To make sure everyone is using GHAS is to set up a security policy at the organization level.</li> <li>Policies can be configured for all organizations owned by your account, or for individual organizations.</li> <li>To configure the policy on a organization level:<ul> <li><code>Policies</code> &gt; <code>Advanced security</code></li> <li>Under <code>GitHub Advanced Security</code> select the drop-down menu and select a policy for the organizations owned by your enterprise:<ul> <li>Options are:<ul> <li>Allow for all organizations</li> <li>Allow for selected organizations</li> <li>Never allow</li> </ul> </li> </ul> </li> <li>Disallowing Advanced Security for an organization prevents repository administrators from enabling Advanced Security features for additional repositories, but does not disable the features for repositories where the features are already enabled.</li> <li>GitHub bills for Advanced Security on a per-committer basis when setting up a policy at the organization level.</li> </ul> </li> <li>Configure policies at the repository level:<ul> <li>add <code>SECURITY.md</code> file to the root, <code>docs</code> or <code>.github</code> folder of your repository.</li> <li>When someone creates an issue, they will see a link to project's security policy.</li> <li>After someone reports a security vulnerability in your project, you can use GitHub Security Advisories to disclose, fix, and publish information about the vulnerability.</li> <li>To create a security policy:<ul> <li><code>Security</code> &gt; <code>Security policy</code></li> <li>Click <code>Start setup</code></li> <li>In the <code>SECURITY.md</code> file, add information about supported versions of your project and how to report a vulnerability.</li> <li>Commit the change to the repository.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Use the Security Overview to monitor security alerts.</p> <ul> <li>Security Overview is available in the <code>Security</code> tab.</li> <li><code>Organization level</code>: displays aggregate and repository-specific security information for repositories owned by your organization. You can also filter information per security feature.</li> <li><code>Team level</code>: Security Overview displays repository-specific security information for repositories that the team has admin privileges for.</li> <li><code>Repository level</code>: shows which security features are enabled for the repository and offers the option to configure any available security features not currently in use.</li> <li>Security overview is usable for broad and specific analysis due to high level of interactivity and numerous filters.</li> </ul> </li> <li> <p>Use the GitHub Advanced Security API endpoints to manage the GitHub Advanced Security features and alerts.</p> <ul> <li>GitHub has different API's for it's Security features:<ul> <li><code>Code scanning</code>: Code Scanning API<ul> <li>Retrieve and update code scanning alerts from a repository</li> <li>Create automated reports for code scanning alerts in an organization</li> <li>Upload analysis results generated using offline code scanning tools</li> </ul> </li> <li><code>Secret scanning</code>: Repos API, Secret Scanning API<ul> <li>Enable or disable secret scanning for a repository</li> <li>Retrieve and update secret scanning alerts from a private repository</li> </ul> </li> <li><code>Dependancy review</code>: Repos API, GraphQL API<ul> <li>Enable and disable dependency alerts and the dependency graph for a repository</li> <li>Enable and disable security fixes for a repository</li> <li>View dependency information</li> </ul> </li> </ul> </li> <li>To automate security workflows, set up a correct permissions for the <code>GITHUB_TOKEN</code> to make authenticated API calls.</li> <li><code>GITHUB_TOKEN</code> permissions can be modified in individual workflows using the <code>permissions</code> key.</li> <li>When the permissions key is used, all unspecified permissions are set to no access, with the exception of the metadata scope, which always gets read access.</li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/","title":"8. Manage sensitive data and security policies within GitHub","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#setting-security-policies","title":"Setting security policies:","text":"<ul> <li>Using policies, you can set security policies individually at each level of your control: repository, organization, or enterprise.</li> <li>You can grant owners access control or make enterprise-wide access restrictions as admin.</li> <li>Documentation and security settings have three purposes: standardization for consistent responses, compliance with industry-standard practices, and prevention of critical failure by defending against security breaches.</li> <li>The permissions you can grant to users on each level of your control are:<ul> <li><code>None</code></li> <li><code>Read</code></li> <li><code>Write</code></li> <li><code>Admin</code></li> </ul> </li> <li>This permissions can be granted:<ul> <li>For <code>organization</code>: <code>Settings</code> &gt; <code>You organization</code></li> <li>For <code>enterprise</code>: <code>Your enterprise</code> &gt; <code>Policies</code> &gt; <code>Repository policies</code></li> </ul> </li> <li>Only GitHub Enterprise administrators and organization owners can configure organization security settings.</li> </ul>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#documentation","title":"Documentation","text":"<ul> <li>As administrator, when you create a new repository, you start with creating certain default health files.</li> <li>Other default community health files can be:<ul> <li><code>CODE_OF_CONDUCT.md</code></li> <li><code>CONTRIBUTING.md</code></li> <li><code>FUNDING.yml</code></li> <li><code>SECURITY.md</code></li> <li><code>SUPPORT.md</code></li> <li>Issue and pull request templates and <code>config.yml</code></li> </ul> </li> <li>GitHub considers these files to have specific purpose and requires to follow the listed naming scheme</li> <li>These files record information about: security preparation, key contacts, and the project background.</li> <li>GitHub will use and display these default files for any repository owned by the account that does not have its own file of that type in any of the following places:<ul> <li>The root of the repository</li> <li>The <code>.github</code> directory</li> <li>The <code>docs</code> directory</li> </ul> </li> <li><code>SECURITY.md</code> is primary document for communicating security information. It includes:<ul> <li>a list of supported versions of project</li> <li>a way to report a security vulnerability</li> <li>It also may include:<ul> <li>Information about the project's complieance with key privacy and security laws</li> <li>Technologies that administrators and stakeholders use to secure information</li> <li>Known risks</li> </ul> </li> </ul> </li> </ul>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#security-advisories","title":"Security Advisories","text":"<ul> <li>Administrators are responsible for publishing security advisories</li> <li>Security advisories should be comprehensive and include:  <ul> <li>Product and version affected</li> <li>Severity</li> <li>Types of security weaknesses addressed by the project owners actions</li> <li>Impact, status of patches, and workarounds</li> </ul> </li> </ul>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#scrub-sensitive-data-from-a-repository","title":"Scrub sensitive data from a repository","text":"<ul> <li>Automation:<ul> <li>pre-commit hooks (scripts that Git executes prior to the commit event, to scan for sensitive data)</li> <li>The most popular pre-commit hooks are:<ul> <li>Gitleaks</li> <li>pre-commit plugins:<ul> <li><code>detect-aws-credentials</code></li> <li><code>detect-private-key</code></li> <li><code>secret_filename</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Removing unwanted files from repository's history:<ul> <li><code>git filter-repo</code> command</li> <li><code>BFG Repo-Cleaner</code> open source tool</li> </ul> </li> <li>Whether you choose <code>git filter-repo</code> or <code>BFG Repo-Cleaner</code>, a user that pushes a commit to GitHub containing sensitive data has already crossed an important line; the organization should consider that data to be compromised and change it immediately.</li> <li><code>git filter-repo</code> allows the removal of passwords or renaming of specific files or file sets.<ul> <li>The syntax is complex and it has strong risk of creating unforeseen problems in a repository's integrity, especially if its executed on Windows operating system.</li> </ul> </li> <li><code>BFG Repo-Cleaner</code> is efficient and easy to use. It provides a set of default actions to choose from that match many common use cases related to sensitive data.<ul> <li>The tool is limited in its capabilities to these cases, giving you little opportunity to customize for unusual circumstances.</li> </ul> </li> <li>Both tools rewrire repository's history, which changes the SHAs for existing commits that you alter and any dependent commits</li> <li>Changed commit SHAs may affect open pull requests in repository</li> <li>GitHub recommend merging or closing all open pull requests before removing files from repository using these tools.</li> <li>Using <code>BFG Repo-Cleaner</code>:<ul> <li>To remove file with sensitive data and leave latest commit untouched, run:<ul> <li><code>bfg --delete-files YOUR-FILE-WITH-SENSITIVE-DATA</code></li> </ul> </li> <li>To replace all text listed in <code>passwords.txt</code>, wherever it can be fount in repository's history, run:<ul> <li><code>bfg --replace-text passwords.txt</code></li> </ul> </li> <li>After the sensitive data is removed, you must force push changes to GitHub:<ul> <li><code>git push --force</code></li> </ul> </li> </ul> </li> <li>Using <code>git filter-repo</code>:<ul> <li>If you run <code>git filter-repo</code> after stashing changes, you won't be able to retrieve your changes with other stash commands. Before running <code>git filter-repo</code>, GitHub recommend unstashing changes you've made. To unstash changes, run:<ul> <li><code>git stash show -p | git apply -R</code></li> </ul> </li> <li>Install latest release of the <code>git filter-repo</code> tool</li> <li>Navigate into repository's local working directory</li> <li>Run the following command:<ul> <li><code>git filter-repo --invert-paths --path PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA</code><ul> <li>This command forces Git to process the entire history of every branch and tag</li> <li>Removes the specified file</li> <li>Removes some configurations such as the remote URL stired in the <code>.git/config</code> file</li> <li>Overwrites existing tags</li> </ul> </li> </ul> </li> <li>Add file with sensitive data to <code>.gitignore</code> and verify the process</li> <li>Force push changes to GitHub<ul> <li><code>git push origin --force --all</code></li> </ul> </li> <li>In order to remove the sensitive file from tagged releases, you will also need to force-push against Git tags:<ul> <li><code>git push origin --force --tags</code></li> </ul> </li> </ul> </li> <li>GitHub support technicians can assist with removing confidential information</li> <li>For instance you might have removed sensitive data from a repository, however you need to make sure they don't appear in forks of that repository</li> <li>Private information removal requests are appropriate for:<ul> <li>Access credentials</li> <li>AWS tokens</li> <li>Documentation (such as network diagrams or architecture)</li> <li>Information related to and posing a security risk to you as an individual</li> </ul> </li> </ul>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/8.%20Manage%20sensitive%20data%20and%20security%20policies%20within%20GitHub/#reporting-and-logging","title":"Reporting and logging","text":"<ul> <li>log records is the information about actions, that affect the organization including:<ul> <li>The repository in which the action was performed</li> <li>The user that performed the action</li> <li>The action that was performed</li> <li>Which country/region in which the action took place</li> <li>The date and time of the action</li> </ul> </li> <li>You can access the audit log using GitHub.com, GHES or GitHub AE to review actions from the past 90 days</li> <li>You can use GraphQL API to retrieve filtered information from the past 120 days<ul> <li>GraphQL can monitor:<ul> <li>Access to your organization or repository settings</li> <li>Changes in permissions</li> <li>Added or removed users in an organization, repository, or team</li> <li>Users being promoted to admin</li> <li>Changes to permissions of a GitHub App</li> </ul> </li> <li>GraphQL cannot provide information about Git events</li> </ul> </li> <li>You can use REST API to retrieve information from the past 90 days<ul> <li>It monitor the same actions as the GraphQL API</li> <li>Information about Git events only remains in the log for 7 days</li> </ul> </li> <li>Generate reports for auditing:<ul> <li>You can export audit logs in a common format by accessing the <code>Audit log</code> from the <code>Settings</code> sidebar in <code>You organization</code> by choosing the <code>Export</code> drop-down menu</li> <li>You can filter the audit log results by adding a qualifier and accompanying value to the <code>Filters</code> field next to the <code>Export</code> drop-down menu. Qualifiers and example values:<ul> <li><code>action</code>: <code>team.create</code></li> <li><code>actor</code>: <code>octocat</code></li> <li><code>user</code>: <code>codertocat</code></li> <li><code>org</code>: <code>octo-org</code></li> <li><code>repo</code>: <code>octo-org/octo-repo</code></li> <li><code>created</code>: <code>2020-01-01</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/9.%20Required%20permissions/","title":"9. Required permissions","text":"<ol> <li> <p>Dependency graph:</p> <ul> <li>By default, enabling this feature requires owner or admin role.</li> </ul> </li> <li> <p>Dependabot alerts:</p> <ul> <li>Maintainable only by organization owners and administrators.</li> <li>By default, only repository owners and administrators are able to receive and dismiss alerts.<ul> <li>Administrators and owners grant other teams and users with access to the repository, permissions to view and dismiss alerts. <code>Code security and analysis</code> &gt; <code>Access to alerts</code></li> </ul> </li> <li>By default, only repository owners and administrators are able to receive Dependabot alerts for their repositories.<ul> <li>Administrators and onwers can grant other teams and users with access to the repository, permission to view and dismiss Dependabot alerts</li> </ul> </li> <li>Repository administrators and owners can set up Dependabot alerts for private repositories and for some GHES repositories. <ul> <li>By enabling these features, GitHub get permission to perform <code>read-only</code> analysis of those specific repositories.</li> </ul> </li> <li>Only organization owner can enable the dependency graph and Dependabot alerts for all of the repositories at once.<ul> <li>Owner of GitHub Enterprise, who is also owner of the connected GitHub Cloud organization or enterprise account can enable the dependency graph and Dependabot alerts for GitHub Server instance.</li> </ul> </li> </ul> </li> <li> <p>Secret Scanning:</p> <ul> <li>Maintainable only by organization owners and administrators.</li> <li>Feature is available for all public repositories, and for private repositories owned by organizations with enabled GHAS license.<ul> <li>For public repositories it cannot be configured or turned off.</li> <li>Must be enabled manually on private repositories</li> </ul> </li> <li>Administrators and organization onwers can give view access to security alerts to people or teams who have write access to the repository.</li> <li>Mainly can be configured in <code>Settings</code> &gt; <code>Security &amp; analysis</code></li> <li>GitHub notifies the following users of secret scanning alerts on a repository:<ul> <li>Repository administrators</li> <li>Organization owners</li> <li>Authors of commits that trigger alerts</li> </ul> </li> </ul> </li> <li> <p>Code Scanning:</p> <ul> <li>Maintainable for everyone with a write permission to a repository.</li> <li>Requires write permissions to a repository to set up or configure code scanning</li> <li>Can be controlled mainly in <code>security</code> tab of the repository</li> <li>The CodeQL CLI is free to use on public repositories that are maintained on GitHub.com, and available to use on private repositories that are owned by customers with an Advanced Security license.</li> </ul> </li> <li> <p>Security policies:</p> <ul> <li>Only GitHub Enterprise administrators and organization owners can configure organization security settings.</li> <li>Using policies, administrator can set security policies individually at each level of control: repository, organization, or enterprise.</li> <li>Administrator can grant owners access control or make enterprise-wide access restrictions.</li> <li>The permissions adminstrator can grant to users on each level of control are:<ul> <li><code>None</code></li> <li><code>Read</code></li> <li><code>Write</code></li> <li><code>Admin</code></li> <li>This permissions can be granted:<ul> <li>For <code>organization</code>: <code>Settings</code> &gt; <code>You organization</code></li> <li>For <code>enterprise</code>: <code>Your enterprise</code> &gt; <code>Policies</code> &gt; <code>Repository policies</code></li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Documentation</p> <ul> <li>When administrator creates a new repository, he starts with creating certain default health files.</li> <li>GitHub will use and display these default files for any repository owned by the account that does not have its own file of that type in any of the following places:<ul> <li>The root of the repository</li> <li>The <code>.github</code> directory</li> <li>The <code>docs</code> directory</li> </ul> </li> </ul> </li> <li> <p>Security Advisories</p> <ul> <li>Administrators are responsible for publishing security advisories</li> <li>Security advisories should be comprehensive and include:  <ul> <li>Product and version affected</li> <li>Severity</li> <li>Types of security weaknesses addressed by the project owners actions</li> <li>Impact, status of patches, and workarounds</li> </ul> </li> </ul> </li> <li> <p>Scrub sensitive data from a repository</p> <ul> <li>Administrators are responsibe for removing sensitive data from a repository or its history</li> </ul> </li> <li> <p>Reporting and logging</p> <ul> <li>Logs are available to organization owners</li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Question%20%26%20Answers/","title":"Question & Answers","text":"<ol> <li> <p>What is the name of the code scanning workflow file? </p> <ul> <li><code>codeql-analysis.yml</code></li> </ul> </li> <li> <p>You want to add the CodeQL workflow to your repository. What is the correct navigation path to achieve that? </p> <ul> <li><code>Security</code> &gt; <code>Set up code scanning</code> &gt; <code>Set up this workflow</code></li> </ul> </li> <li> <p>What action GitHub Actions uses to upload a third-party SARIF file to a repository? </p> <ul> <li><code>upload-sarif</code></li> </ul> </li> <li> <p>How to exclude <code>.md</code> and <code>.txt</code> files from code scanning?     <pre><code>paths-ignore:\n  - '**/*.md'\n  - '**/*.txt'\n</code></pre></p> </li> <li> <p>What is the first step in codeQL analysis? </p> <ul> <li>creating database</li> </ul> </li> <li> <p>How does CodeQL database creation work for compiled languages?</p> <ul> <li>monitoring normal build process</li> </ul> </li> <li> <p>What parameter do you use when you want to use external configuration file for code scanning?  </p> <ul> <li><code>config-file</code></li> </ul> </li> <li> <p>When you use language matrix in your code scanning workflow, what does it mean? </p> <ul> <li>CodeQL is analyzes only the languages in the matrix</li> </ul> </li> <li> <p>What building options there are for compiled languages in code scanning?</p> <ul> <li>auto-build, manually add build steps</li> </ul> </li> <li> <p>What do you need when you are creating custom pattern for secret scanning (select two)? </p> <ul> <li>Pattern name, secret format</li> </ul> </li> <li> <p>In which document do you tell how to report a security vulnerabilities in the project? </p> <ul> <li><code>SECURITY.md</code></li> </ul> </li> <li> <p>Two questions about depandabot.yml syntax:</p> <ul> <li>First one asks about the top level keys:<ul> <li>version and updates </li> </ul> </li> <li>the second about the keys under updates: <ul> <li>package-ecosystem, directory and schedule.interval</li> </ul> </li> </ul> </li> <li> <p>How many required reviewers does Depandabot assign by default without a configured depandabot.yml file? Options: 0, 1, 2 or 3</p> <ul> <li>0</li> </ul> </li> <li> <p>In query suite file, what metadata tag matches on the last path component of the query? </p> <ul> <li>query filename</li> </ul> </li> <li> <p>What is the instruction in a query suite file to look for one or more specified .ql files? </p> <ul> <li>query</li> </ul> </li> <li> <p>What query metadata property results in a simple alert? </p> <ul> <li>'@kind problem'</li> </ul> </li> <li> <p>Question about notification settings contents. Don't remember the specific question, but familiarise yourself with those settings.</p> <ul> <li>By default users receive notifications:<ul> <li>By email</li> <li>In the GitHub UI</li> <li>In the GitHub mobile app</li> <li>On the command line</li> <li>In your inbox</li> </ul> </li> <li>You can change the default settings in <code>Settings</code> &gt; <code>Notifications</code> &gt; <code>Dependabot alerts</code></li> </ul> </li> <li> <p>What are the consequences of someone ignoring code scanning alerts? </p> <ul> <li>Using data insecurely, passing dangerous arguments to functions and leaking sensitive information.</li> </ul> </li> <li> <p>What is a mandatory key in dependabot.yml </p> <ul> <li>version</li> </ul> </li> <li> <p>What is default access for the actions scope for the restricted GITHUB_TOKEN </p> <ul> <li>none</li> </ul> </li> <li> <p>How you verify that you have configured correctly CodeQL CLI setup? </p> <ul> <li>run subcommands, as available languages</li> </ul> </li> <li> <p>What is required to communicate with GraphQL server?</p> <ul> <li>token with <code>user</code>, <code>public_repo</code>, <code>repo</code>, <code>repo_deployment</code>, <code>repo:status</code>, <code>read:repo_hook</code>, <code>read:org</code>, <code>read:public_key</code> and <code>read:gpg_key</code> scopes</li> </ul> </li> <li> <p>What is end point for GraphQL API? </p> <ul> <li><code>https://api.github.com/graphql</code></li> </ul> </li> <li> <p>What are direct dependencies?</p> <ul> <li>Dependencies that are explicitly defined in the manifest or lock file.</li> </ul> </li> <li> <p>When is a Dependabot alert generated?</p> <ul> <li>Whenever a new vulnerability is added to the GitHub Advisory Database.</li> </ul> </li> <li> <p>What is a prerequisite for Dependabot to automatically enable security updates for a repository?</p> <ul> <li>Repository is public</li> </ul> </li> <li> <p>What query can you use to view all the notifications you've marked as done?</p> <ul> <li><code>is:done</code></li> </ul> </li> <li> <p>To which area of focus does GitHub dependency management belong?</p> <ul> <li>Supply chain</li> </ul> </li> <li> <p>What's the purpose of security advisories?</p> <ul> <li>To provide a safe space for code maintainers to discuss how to best address errors and vulnerabilities found in the codebase.</li> </ul> </li> <li> <p>Which GitHub feature is powered by CodeQL?</p> <ul> <li>Code scanning</li> </ul> </li> <li> <p>What does the term 'shifting left' mean?</p> <ul> <li>Incorporating security principles early in the software development lifecycle</li> </ul> </li> <li> <p>Which technology does GitHub use to authenticate one application with another?</p> <ul> <li>Secrets</li> </ul> </li> <li> <p>What's a common cause of security breaches?</p> <ul> <li>Administrators delay patching a system after updates are available.</li> </ul> </li> <li> <p>What do you need to do if you want to change the settings for secret scanning on a public repository?</p> <ul> <li>Switch the repository to a private one with GitHub Advanced Security</li> </ul> </li> <li> <p>Where can you configure the recipients of secret scanning alerts?</p> <ul> <li>In the Security and analysis settings of a repository</li> </ul> </li> <li> <p>How many custom secret patterns can you create?</p> <ul> <li>500 for enterprise/organization and 100 per private repository</li> </ul> </li> <li> <p>When code scanning is enabled, what is one default event that triggers a scan?</p> <ul> <li>Pushing a change.</li> </ul> </li> <li> <p>What tools are used to upload a SARIF file?</p> <ul> <li>GitHub Actions, the code scanning API, and the CodeQL CLI.</li> </ul> </li> <li> <p>What is the difference between scheduled versus triggered events in code scanning?</p> <ul> <li>Scheduled events run based on a specified schedule and triggered events run on code events such a push.</li> </ul> </li> <li> <p>What are three main commands for the CodeQL CLI?</p> <ul> <li><code>codeql database create</code></li> <li><code>codeql resolve languages</code></li> <li><code>codeql resolve qlpacks</code></li> </ul> </li> <li> <p>Which command definition is required to use in order to create database with multiple languages?</p> <ul> <li><code>--db-cluster</code> along with <code>--no-run-unnecessary-builds</code> to suppress the build command for languages where the CodeQL CLI doesn't need to monitor the build process.</li> </ul> </li> <li> <p>What does CodeQL first do when creating a database?</p> <ul> <li>Extracts a single relational representation of each source file</li> </ul> </li> <li> <p>What is the format of the command used to create and analyze CodeQL database from the CLI?</p> <ul> <li><code>codeql [command] [subcommand]</code></li> </ul> </li> <li> <p>What is an extractor?</p> <ul> <li>A tool that produces the relational data</li> </ul> </li> <li> <p>The CLI's built-in search operations does which of the following?</p> <ul> <li>Automatically looks in all of its sibling directories for the files used in the database creation and analysis</li> </ul> </li> <li> <p>By default, which severity level will cause a pull request check failure when using code scanning?</p> <ul> <li>Error, and high or critical</li> </ul> </li> <li> <p>Which is one way to optimize CodeQL analysis runtimes?</p> <ul> <li>Increase the memory</li> </ul> </li> <li> <p>What are three default query suites?</p> <ul> <li><code>code-scanning</code></li> <li><code>security-extended</code></li> <li><code>security-and-quality</code></li> </ul> </li> <li> <p>What file QL pack must contain?</p> <ul> <li><code>qlpack.yml</code></li> </ul> </li> <li> <p>What is the format for all QL extensions?</p> <ul> <li><code>.ql</code>: query</li> <li><code>.qll</code>: library</li> <li><code>.qls</code>: sequence of instructions</li> </ul> </li> <li> <p>In CodeQL, errors like bugs and vulnerabilities are modeled as:</p> <ul> <li>Queries</li> </ul> </li> <li> <p>How many default query suites are there with GitHub code scanning with CodeQL?</p> <ul> <li>3</li> </ul> </li> <li> <p>What are all the parts of a CodeQL database?</p> <ul> <li>Hierarchical representation of the code</li> <li>data-flow graph</li> <li>control-flow graph</li> <li>A representation of the language's abstract syntax tree</li> </ul> </li> <li> <p>To create a database, CodeQL extracts:</p> <ul> <li>A single relational representation of each source file in the codebase.</li> </ul> </li> <li> <p>How does CodeQL database creation work for compiled languages?</p> <ul> <li>For compiled languages, extraction works by monitoring the normal build process.</li> </ul> </li> <li> <p>What are all the steps of CodeQL analysis?</p> <ul> <li>Creating database</li> <li>Running queries against the database</li> <li>Interpreting the results</li> </ul> </li> <li> <p>What feature does QL add to the Datalog programming language?</p> <ul> <li>Support for aggregates</li> </ul> </li> <li> <p>One major difference between QL and general purpose programming languages is:</p> <ul> <li>QL does not have any imperative features such as assignments to variables or file system operations.</li> </ul> </li> <li> <p>What semantics of QL are based on?</p> <ul> <li>Datalog</li> </ul> </li> <li> <p>What enables you to customize how code scanning analyzes your code?</p> <ul> <li>The code scanning workflow</li> </ul> </li> <li> <p>Dave's company wants to use GitHub actions to generate code scanning alerts. What tools can they use for code analysis?</p> <ul> <li>CodeQL or supported third party tools.</li> </ul> </li> <li> <p>What are two options for specifying which queries you want to run with CodeQL code scanning?</p> <ul> <li>Using code scanning workflow</li> <li>Using a custom configuration file</li> </ul> </li> <li> <p>How to specify query packs in a workflow file?     <pre><code>- uses: github/codeql-action/init@v1\nwith:\n# Comma-separated list of packs to download\npacks: scope/pack1,scope/pack2@1.2.3,scope/pack3@~1.2.3\n</code></pre></p> </li> <li> <p>What is required to use if the queries are in a private repository?</p> <ul> <li><code>external-repository-token</code> parameter with <code>${{ secrets.ACCESS_TOKEN }}</code></li> </ul> </li> <li> <p>What options are available for referencing other queries in a workflow file?</p> <ul> <li>Workflow files can reference query packs, individual query files, and query suite files.</li> </ul> </li> <li> <p>What is the method for ensuring that any packs or queries referenced in a custom configuration file are run in addition to the ones included in the workflow file?</p> <ul> <li>Prefix the value of packs or queries in the workflow file with the <code>+</code> symbol.</li> </ul> </li> <li> <p>What is the basic CodeQL query file extension structure and what it should contain?</p> <ul> <li>file extension structure is <code>.ql</code> and contains a <code>select</code> clause.</li> </ul> </li> <li> <p>What are the two types of queries and what it requires?</p> <ul> <li>@kind has only two options:</li> <li>problem (same as Alert queries) </li> <li>path problem (same as Path queries)</li> <li>metadata is required</li> </ul> </li> <li> <p>How qlpack.yml syntax looks like?     <pre><code>name: codeql/java-queries\nversion: 0.0.6-dev\ngroups: java\nsuites: codeql-suites\nextractor: java\ndefaultSuiteFile: codeql-suites/java-code-scanning.qls\ndependencies:\n    codeql/java-all: \"*\"\n    codeql/suite-helpers: \"*\"\n</code></pre></p> </li> <li> <p>How to use query packs in the workflow file?     <pre><code>packs:\n# Use the latest version of 'pack1' published by 'scope'\n- scope/pack1\n# Use version 1.23 of 'pack2'\n- scope/pack2@v1.2.3\n# Use the latest version of 'pack3' compatible with 1.23\n- scope/pack3@~1.2.3\n</code></pre></p> </li> <li> <p>How to use queries in the workflow file?     <pre><code>queries:\n  - uses: ./my-basic-queries/example-query.ql\n  - uses: ./my-advanced-queries\n  - uses: ./query-suites/my-security-queries.qls\n</code></pre></p> </li> <li> <p>What action is required to load config-file?</p> <ul> <li><code>github/codeql-action/init@v1</code></li> </ul> </li> <li> <p>How to disable default queries in the workflow file?</p> <ul> <li>By setting <code>disable-default-queries</code> parameter to <code>true</code></li> </ul> </li> <li> <p>What is the method for specifying other queries in a custom configuration file?</p> <ul> <li>A 'queries' array where each element contains a 'uses' parameter.</li> </ul> </li> <li> <p>Dave's repository contains code in multiple languages, but he would like CodeQL code scanning to only analyze C++ and Python. Which of the following options is a method to do that?</p> <ul> <li>List the languages that he wants to analyze in the 'languages' array in the workflow file.</li> <li>An example: <pre><code>  packs:\n    # Use these packs for JavaScript analysis\n    javascript:\n      - scope/js-pack1\n      - scope/js-pack2\n    # Use these packs for Java analysis\n    java:\n      - scope/java-pack1\n      - scope/java-pack2@v1.0.0\n</code></pre></li> </ul> </li> <li> <p>What are the commands in order to analyze or upload results to GitHub?</p> <ul> <li><code>codeql database analyze</code></li> <li><code>githb upload-results</code></li> </ul> </li> <li> <p>What is the appropriate syntax to create a database with multiple languages?     <pre><code>codeql database create &lt;database&gt; --command&lt;build&gt; \\\n--db-cluster --language=&lt;language-identifier&gt;,&lt;language-identifier&gt;\n</code></pre></p> </li> <li> <p>What does the <code>--command</code> syntax do?</p> <ul> <li>tell the tool the build command for the codebase</li> </ul> </li> <li> <p>Which command is used to create a CodeQL database using the CLI?</p> <ul> <li>codeql database create</li> </ul> </li> <li> <p>What is the file format generated by use of the database analyze command?</p> <ul> <li>SARIF</li> </ul> </li> <li> <p>Manual build steps in your workflow file are necessary in which situation?</p> <ul> <li>If there are supported languages with a non-standard build process.</li> </ul> </li> <li> <p>Autobuild is currently succeeding for one of the languages in Layla's repository, but failing for another. What should she do?</p> <ul> <li>Add language-specific build commands for the language where autobuild is failing.</li> </ul> </li> <li> <p>Which GitHub Advanced Security feature is not available on public repositories? (Secret scanning, Security Overview, Code scanning)</p> <ul> <li>Security Overview</li> </ul> </li> <li> <p>Where can you enable GitHub Advanced Security for all the private and internal repositories in an organization?</p> <ul> <li>In the organization's Code and security settings</li> </ul> </li> <li> <p>What can you do to ensure that everyone in your organization is using GitHub Advanced Security?</p> <ul> <li>Set a security policy at the organization level</li> </ul> </li> <li> <p>What should you keep in mind when using GitHub Actions for your security workflows?</p> <ul> <li>You should correctly set up the permissions for the GITHUB_TOKEN used to make authenticated API calls.</li> </ul> </li> <li> <p>What file should you use to create documentation for collaborators that lists supported versions of the project?</p> <ul> <li><code>SECURITY.md</code></li> </ul> </li> <li> <p>What tool should you use to automate part of your security process?</p> <ul> <li>Add Dependabot to your code base</li> </ul> </li> <li> <p>Which two pieces of information should be included in a security advisory?</p> <ul> <li>Product affected and severity</li> </ul> </li> <li> <p>What two pieces of information are included in your organization\u2019s log?</p> <ul> <li>The user that performed the action and the date and time of the action</li> </ul> </li> <li> <p>What are all the information logs includes?</p> <ul> <li>which repository an action was performed in</li> <li>the user that performed the action </li> <li>which country/region the action took place in</li> <li>the date and time of the action</li> </ul> </li> <li> <p>What GHAS features are not accessible from the user interface?</p> <ul> <li>CodeQL and third-party tool integration</li> </ul> </li> <li> <p>Code scanning is using GitHub Advisory Database. Where this database populates information from?</p> <ul> <li>1) National vulnerability database, 2) combination of machine learning and human reviews to detect vulnerabilities in public commits on GitHub, 3) Security advisories reported on GitHub, 4) The npm Security advisories database.</li> </ul> </li> <li> <p>What features Dependabot provides?</p> <ul> <li>Dependabot alerts, security updates, verion updates</li> </ul> </li> <li> <p>The <code>version</code> configuration in <code>dependabot.yml</code> file must be set to:</p> <ul> <li><code>2</code></li> </ul> </li> <li> <p>What are required names for configuration files in GHAS?</p> <ul> <li><code>dependabot.yml</code>: for Dependabot configuration</li> <li>QL pack must contain a <code>qlpack.yml</code> file</li> <li>code scanning workflow file must be named as <code>codeql-config.yml</code></li> </ul> </li> <li> <p>Who will the secret scanning tool notify about the breach?</p> <ul> <li>organization owner, repository administrator, and author of commits that trigger the alert</li> </ul> </li> <li> <p>What is a supported custom media type for the code scanning REST API?</p> <ul> <li><code>application/sarif+json</code></li> </ul> </li> <li> <p>With what version data is fromatted as SARIF?</p> <ul> <li><code>2.1.0</code></li> </ul> </li> <li> <p>How CodeQL works during data base creation for interpreted languages?</p> <ul> <li>CodeQL extracts a single relation representation of each source file in the codebase by running on the source code, resolving dependencies to give an accurate representation of the codebase.</li> </ul> </li> <li> <p>How many options users have for specifying which queries to run with CodeQL code scanning?</p> <ul> <li>Two options, using code scanning workflow or a custom configuration file.</li> </ul> </li> <li> <p>What are the options to specify the additional queries?</p> <ul> <li><code>packs</code> to install one or more CodeQL query packs</li> <li><code>queries</code> to specify a single <code>.ql</code> file, a directory containing multiple <code>.ql</code> files, query definition file <code>.qls</code>, or any combintation</li> <li>It is possible to use both packs and queries in the same workflow file.</li> </ul> </li> <li> <p>How to add one or more CodeQL query packs?</p> <ul> <li>by using <code>with: packs</code> parameter along with the <code>uses: github/codeql-action/init@v1</code> action in the workflow file.</li> </ul> </li> <li> <p>How to specify a comma-separated list of packs to download in the workflow?     <pre><code>- uses: github/codeql-action/init@v1\n  with:\n    # Comma-separated list of packs to download\n    packs: scope/pack1,scope/pack2@1.2.3,scope/pack3@~1.2.3\n</code></pre></p> </li> <li> <p>What is the value to provide a token to access queries stored in private repository?</p> <ul> <li><code>external-repository-token: ${{ secrets.ACCESS_TOKEN }}</code></li> </ul> </li> <li> <p>What query suites are built into CodeQL code scanning tool?</p> <ul> <li><code>code-scanning, security-extended and security-and-quality</code></li> </ul> </li> <li> <p>What is the action to take to specify the configuration file for CodeQL code scanning in the workflow file?</p> <ul> <li>by using <code>github/codeql-action/init@v1</code> along with <code>with: config-file: &lt;path-to-config-file&gt;</code> parameter.</li> </ul> </li> <li> <p>How to refernce to a configuration file located in a external repositroy?</p> <ul> <li>by using <code>OWNER/REPOSITORY/FILENAME@BRANCH</code> syntax</li> </ul> </li> <li> <p>How do you specify and CodeQL query packs to run in a custom configuration file?</p> <ul> <li>by using a nested map of packs: <pre><code>packs:\n  # Use these packs for JavaScript analysis\n  javascript:\n    - scope/js-pack1\n    - scope/js-pack2\n  # Use these packs for Java analysis\n  java:\n    - scope/java-pack1\n</code></pre></li> </ul> </li> <li> <p>What is the rule for character when using <code>paths-ignore</code> keyword?</p> <ul> <li>characters can only be at the start or end of a line, or surrounded by slashes. For example <code>foo/**, **/foo, and foo/**/bar</code> are all valid patterns.</li> </ul> </li> <li> <p>What kind of information CodeQL database schema includes?</p> <ul> <li><code>expressions</code> and <code>statements</code> tables</li> <li>CodeQL library defines classes to provide a layer of abstraction over the each of these tables. This includes the related auxuliary tables <code>Expr</code> and <code>Stmt</code>.</li> </ul> </li> <li> <p>What are the levels to monitor security alerts using Security overview?</p> <ul> <li><code>Organization</code>, <code>Team</code> and <code>Repository</code> levels</li> </ul> </li> <li> <p>What are the permissions you can grant to users on each level of your control over GitHub Advanced Security?</p> <ul> <li><code>None</code>, <code>Read</code>, <code>Write</code> and <code>Admin</code> permissions</li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Code%20Scanning/","title":"Code Scanning","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Code%20Scanning/#add-the-codeql-workflow-to-your-repository","title":"Add the CodeQL workflow to your repository","text":"<ol> <li>Navigate to the main page of the repository.</li> <li>Under your repository name, click <code>Security</code>.</li> <li>Click <code>Set up code scanning</code>. If this option is not available, ask an organization owner or repository administrator to enable GitHub Advanced Security.</li> <li>In the <code>Get started with code scanning</code> section, click <code>Set up this workflow</code> on the CodeQL analysis workflow.</li> <li>To customize how code scanning scans your code, edit the workflow.</li> <li>Select the <code>Start commit</code> drop-down, and type a commit message.</li> <li>Choose whether you'd like to commit directly to the default branch, or create a new branch and start a pull request.</li> <li>Click <code>Commit new file</code> or <code>Propose new file</code>.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Code%20Scanning/#code-scanning-with-github-actions-and-codeql","title":"Code scanning with GitHub Actions and CodeQL","text":"<ol> <li>Go to the <code>Security</code> tab of your repository.</li> <li>To the right of <code>Code scanning alerts</code>, click <code>Set up code scanning</code>. If code scanning is missing, this means you need to enable GitHub Advanced Security.</li> <li>Under <code>Get started with code scanning</code>, click <code>Set up this workflow</code> on the CodeQL analysis workflow or on a third-party workflow. <ul> <li>Note: Workflows are only displayed if they are relevant for the programming languages detected in the repository. The CodeQL analysis workflow is always displayed, but the \"Set up this workflow\" button is only enabled if CodeQL analysis supports the languages present in the repository.</li> </ul> </li> <li>To customize how code scanning scans your code, edit the workflow. Generally you can commit the CodeQL analysis workflow without making any changes to it. However, many of the third-party workflows require additional configuration, so read the comments in the workflow before committing.</li> <li>Use the Start commit drop-down, and type a commit message.</li> <li>Choose whether you'd like to commit directly to the default branch, or create a new branch and start a pull request.</li> <li>Click Commit new file or Propose new file.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/","title":"Dependabot","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#enable-the-dependency-graph-for-private-repositories","title":"Enable the dependency graph for private repositories","text":"<ol> <li>Go to your GitHub repository.</li> <li>Select your repository <code>Settings</code>.</li> <li>Select <code>Code security and analysis</code>.</li> <li>Select <code>Enable</code> in the dependency graph section</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#view-the-dependency-graph","title":"View the dependency graph","text":"<ol> <li>Go to your <code>GitHub</code> repository.</li> <li>Select your repository <code>Insights</code>.</li> <li>Select <code>Dependency</code> graph.</li> <li>You can select the <code>Dependencies</code> or <code>Dependents</code> tab from the Dependency graph view.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#set-up-dependabot-alerts-for-private-repositories","title":"Set up Dependabot alerts for private repositories","text":"<ol> <li>Sign in to your GitHub account and select your profile photo from the upper right.</li> <li>Select Settings, then select Code security and analysis under Security in the left-side menu.</li> <li>Select Enable all to the right of the feature you want to enable.</li> <li>If you would like these settings to be applied to all new repositories in your organization, then select the Enable by default for new private repositories checkbox.</li> <li>Select Enable FEATURE to enable the feature for all the repositories you own.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#set-up-dependabot-alerts-for-organizations","title":"Set up Dependabot alerts for organizations","text":"<ol> <li>Sign in to your GitHub account and select your profile photo from the upper-right.</li> <li>Select Your organizations.</li> <li>Select Settings next to the organization for which you would like to enable Dependabot alerts.</li> <li>Select Code security and analysis from the left sidebar.</li> <li>On the Configure security and analysis features page, select Enable all next to the feature you want to turn on.</li> <li>If you would like these settings to be applied to all new repositories in your organization, select the Enable by default for new private repositories checkbox.</li> <li>Select Enable FEATURE to enable the feature for all the repositories in your organization.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#grant-access-to-dependabot-alerts","title":"Grant access to Dependabot alerts","text":"<ol> <li>Go to the main page of the repository.</li> <li>In the left menu, select Code security and analysis.</li> <li>In the Access to alerts section, type the name of the person or team that you would like to be able to manage Dependabot alerts in the search bar. Make your selection.</li> <li>Select Save changes.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#resolve-dependabot-alerts","title":"Resolve Dependabot alerts","text":"<p>After Dependabot alerts are enabled, it requires to create a process to regularly review and resolve the them. The following steps explain how to resolve Dependabot alerts:</p> <ol> <li>Go to the main page of the repository</li> <li>Select the <code>Security tab</code> for the repository</li> <li>Select <code>Dependabot alerts</code> from the security sidebar. A list of the Dependabot alerts for that repository will display</li> <li>Select the alert you would like to view.</li> <li>Review the alert details. In some cases, the alert may contain a pull request with an automated security update.</li> <li>Resolve the alert by taking one of the following actions:<ul> <li>Review and merge the pull request.</li> <li>Select Create Dependabot security update to manually fix the vulnerability.</li> <li>Select the Dismiss dropdown and choose a reason for dismissing the vulnerability.</li> </ul> </li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#manually-enable-security-updates","title":"Manually enable security updates","text":"<ol> <li>Sign in to your GitHub account and select your profile photo from the upper-right.</li> <li>Select Settings &gt; Code security and analysis.</li> <li>Select Enable for Dependabot security updates.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#view-dependencies-being-montiredby-dependabot","title":"View dependencies being montiredby Dependabot","text":"<ol> <li>Go to the main page of the repository.</li> <li>Under your repository name, select <code>Insights</code>.</li> <li>Select <code>Dependency graph</code> in the left sidebar.</li> <li>Select <code>Dependabot</code>.</li> <li>Select the three dots next to a package manager to view the files being monitored.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#version-updates-on-forks","title":"Version updates on forks","text":"<ol> <li>Go to the main page of the repository where you want to enable version updates.</li> <li>Select <code>Insights</code>.</li> <li>Select <code>Dependency graph</code> from the left sidebar.</li> <li>Select <code>Dependabot</code>.</li> <li>Select <code>Enable Dependabot</code>.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Dependabot/#allow-dependabot-to-access-private-repositories","title":"Allow Dependabot to access private repositories","text":"<ol> <li>Go to the security and analysis settings for your organization.</li> <li>Under <code>Grant Dependabot access to private repository</code>, select <code>Add private repositories</code> or <code>Add internal and private repositories</code>.</li> <li>Start typing the name of the repository you want to allow.</li> <li>Select the repository you want to allow.</li> <li>Optionally, to remove a repository from the list, go to the right of the repository and select X.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/GraphQL/","title":"GraphQL","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/GraphQL/#set-up-a-graphql-explorer","title":"set up a GraphQL Explorer","text":"<ol> <li>Get a properly configured OAuth token.</li> <li>Open GraphiQL.</li> <li>In the upper-right corner of GraphiQL, select Edit HTTP Headers.</li> <li>In the Key field, enter 'Authorization'. In the Value field, enter Bearer , where  is your generated OAuth token. <li>Select the checkmark to the right of the token to save it.</li> <li>To return to the editor, select outside of the Edit HTTP Headers modal.</li> <li>In the GraphQL Endpoint field, enter https://api.github.com/graphql.</li> <li>In the Method dropdown, select Post.</li>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Secret%20Scanning/","title":"Secret Scanning","text":""},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Secret%20Scanning/#enable-secret-scanning-for-a-private-repository","title":"Enable secret scanning for a private repository","text":"<ol> <li>In your repository, navigate to <code>Settings &gt; Security &amp; analysis</code>.</li> <li>Under <code>Configure security and analysis features</code>, click the <code>Enable</code> button next to <code>GitHub Advanced Security</code>.</li> <li>Review the impact of enabling Advanced Security and click <code>Enable GitHub Advanced Security</code> for this repository.</li> <li>Click the <code>Enable</code> button next to <code>Secret scanning</code>. If you see a <code>Disable button</code>, it means that secret scanning was already enabled at organization level.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Secret%20Scanning/#enable-secret-scanning-for-an-organization","title":"Enable secret scanning for an organization","text":"<ol> <li>In your organization, navigate to <code>Settings</code> &gt; <code>Security &amp; analysis</code>.</li> <li>Under <code>Configure security and analysis features</code>, click the <code>Enable</code> all button next to GitHub Advanced Security.</li> <li>Review the impact of enabling Advanced Security on all repositories and click Enable all.</li> <li>Click the Enable all button next to Secret scanning.</li> <li>Optionally enable the feature by default for new repositories in your organization, and click Enable for eligible repositories.</li> </ol>"},{"location":"GitHub%20Advanced%20Security%20Accreditation/Instructions/Secret%20Scanning/#creating-a-custom-secret-pattern-for-secret-scanning","title":"Creating a custom secret pattern for Secret Scanning","text":"<ol> <li>In your repository, navigate to Settings &gt; Code security &amp; analysis.</li> <li>Under GitHub Advanced Security &gt; Secret scanning, click New pattern.</li> <li>Provide the following details for your custom pattern:<ul> <li>The name of the pattern</li> <li>The pattern of the secret specified as Hyperscan regex</li> <li>A sample test string to make sure your configuration is matching the patterns you expect</li> </ul> </li> </ol>"}]}